<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤ë§ˆíŠ¸ ì»·íŒ… í”Œëœ (Smart CP) - Ver 11.3.1 (Qty Comma Fix)</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

        body {
            font-family: 'Noto Sans KR', sans-serif;
        }

        @media print {
            @page {
                size: A4 portrait;
                margin: 5mm;
            }

            body {
                background: white !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                zoom: 1;
            }

            .print\:hidden {
                display: none !important;
            }

            .print\:p-0 {
                padding: 0 !important;
            }

            .print\:m-0 {
                margin: 0 !important;
            }

            .print\:text-xs {
                font-size: 10px !important;
            }

            .print\:w-full {
                width: 100% !important;
                max-width: 100% !important;
            }

            table {
                width: 100% !important;
                border-collapse: collapse;
                page-break-inside: auto;
            }

            th,
            td {
                border: 1px solid #9ca3af !important;
                padding: 2px !important;
                white-space: nowrap;
            }

            tr {
                page-break-inside: avoid;
                page-break-after: auto;
            }

            .break-before-page {
                page-break-before: always;
            }

            #sidebar,
            .tabs-container,
            .action-buttons,
            .summary-stats-container,
            .stats-table-wrapper {
                display: none !important;
            }

            #main-content {
                margin-left: 0 !important;
                padding: 0 !important;
                width: 100% !important;
            }
        }

        .custom-scrollbar::-webkit-scrollbar {
            height: 8px;
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .modal-fade-in {
            animation: fadeIn 0.2s ease-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .input-cell {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            text-align: center;
            outline: none;
        }

        .input-cell:focus {
            background-color: #e0f2fe;
            font-weight: bold;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900">
    <div id="root"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        window.FirebaseSDK = { initializeApp, getAuth, signInAnonymously };
        window.dispatchEvent(new Event('firebase-sdk-ready'));
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, memo, useCallback, useMemo } = React;

        // --- Icons ---
        const IconWrapper = ({ children, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const Trash2 = (props) => <IconWrapper {...props}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></IconWrapper>;
        const Plus = (props) => <IconWrapper {...props}><path d="M5 12h14" /><path d="M12 5v14" /></IconWrapper>;
        const Calculator = (props) => <IconWrapper {...props}><rect width="16" height="20" x="4" y="2" rx="2" /><line x1="8" x2="16" y1="6" y2="6" /><line x1="16" x2="16" y1="14" y2="18" /><path d="M16 10h.01" /><path d="M12 10h.01" /><path d="M8 10h.01" /><path d="M12 14h.01" /><path d="M8 14h.01" /><path d="M12 18h.01" /><path d="M8 18h.01" /></IconWrapper>;
        const Settings = (props) => <IconWrapper {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></IconWrapper>;
        const FileSpreadsheet = (props) => <IconWrapper {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /><path d="M8 13h2" /><path d="M8 17h2" /><path d="M14 13h2" /><path d="M14 17h2" /></IconWrapper>;
        const FileDown = (props) => <IconWrapper {...props}><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4" /><polyline points="14 2 14 8 20 8" /><path d="M2 15h10" /><path d="M9 18l3-3-3-3" /></IconWrapper>;
        const Building = (props) => <IconWrapper {...props}><rect x="4" y="2" width="16" height="20" rx="2" ry="2" /><path d="M9 22v-4h6v4" /><path d="M8 6h.01" /><path d="M16 6h.01" /><path d="M8 10h.01" /><path d="M16 10h.01" /><path d="M8 14h.01" /><path d="M16 14h.01" /><path d="M8 18h.01" /><path d="M16 18h.01" /></IconWrapper>;
        const Layers = (props) => <IconWrapper {...props}><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></IconWrapper>;
        const X = (props) => <IconWrapper {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></IconWrapper>;
        const Check = (props) => <IconWrapper {...props}><polyline points="20 6 9 17 4 12"></polyline></IconWrapper>;
        const Edit3 = (props) => <IconWrapper {...props}><path d="M12 20h9" /><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></IconWrapper>;
        const EyeOff = (props) => <IconWrapper {...props}><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" /><line x1="1" y1="1" x2="23" y2="23" /></IconWrapper>;
        const Eye = (props) => <IconWrapper {...props}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" /><circle cx="12" cy="12" r="3" /></IconWrapper>;
        const Copy = (props) => <IconWrapper {...props}><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></IconWrapper>;
        const FilePdf = (props) => <IconWrapper {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" /><polyline points="14 2 14 8 20 8" /><path d="M9 15h3a1.5 1.5 0 0 0 0-3H9v4" /><path d="M5 12v4" /><path d="M5 12h2" /><path d="M17 12h-3v4" /><path d="M17 14h-2" /></IconWrapper>;
        const Cloud = (props) => <IconWrapper {...props}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></IconWrapper>;

        // --- Constants ---
        const UNIT_WEIGHT_DATA = {
            "100-100-3.2": 9.52, "100-100-3.0": 8.96, "100-100-2.3": 6.95, "100-100-2.1": 6.37,
            "100-50-2.1": 4.72, "75-75-2.1": 4.72, "50-50-2.1": 3.07
        };

        const STANDARD_STOCKS = {
            "default": [6000, 6600, 7200, 8000],
            "100x100": { "2.1": [6000, 6600, 7200, 8000], "2.3": [6000, 6600, 7200, 8000], "3.0": [6000, 6200, 7200, 8000], "3.2": [6000, 6200, 7200, 8000] },
            "75x75": { "2.1": [6000, 6600, 7200, 8000], "2.3": [6000, 6600, 7200, 8000], "3.0": [6000, 6200, 7200, 8000], "3.2": [6000, 6200, 7200, 8000] },
            "100x50": { "2.1": [6000, 6600, 7200, 8200], "2.3": [6000, 6600, 7200, 8200], "3.0": [6000, 6600, 7200, 8200], "3.2": [6000, 6600, 7200, 8200] },
            "50x50": { "2.1": [6000], "2.3": [6000], "3.0": [6000], "3.2": [6000] }
        };

        // --- Google Sheets Configuration ---
        const CLIENT_ID = '791608320864-ro52gqaonn7ppkoib6due2m48sfv9969.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyBoOVQF_WEEiIZqFIA89ET2Rvt95CUjzWk';
        const SPREADSHEET_ID = '1I0-XY4ZjhbjCBHEbZ36B8QSKb99CQk2aBHgBpBMGLWc';
        const DISCOVERY_DOC = 'https://sheets.googleapis.com/$discovery/rest?version=v4';
        const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';

        const SHEET_ROW_MAP = [
            { row: 5, w: 50, h: 50, t: '2.1', l: 6000 },
            { row: 7, w: 75, h: 75, t: '2.1', l: 6000 }, { row: 8, w: 75, h: 75, t: '2.1', l: 6600 }, { row: 9, w: 75, h: 75, t: '2.1', l: 7200 }, { row: 10, w: 75, h: 75, t: '2.1', l: 8000 },
            { row: 12, w: 100, h: 50, t: '2.1', l: 5000 }, { row: 13, w: 100, h: 50, t: '2.1', l: 6000 }, { row: 14, w: 100, h: 50, t: '2.1', l: 6600 }, { row: 15, w: 100, h: 50, t: '2.1', l: 7200 }, { row: 16, w: 100, h: 50, t: '2.1', l: 8200 },
            { row: 18, w: 100, h: 100, t: '2.1', l: 5000 }, { row: 19, w: 100, h: 100, t: '2.1', l: 6000 }, { row: 20, w: 100, h: 100, t: '2.1', l: 6600 }, { row: 21, w: 100, h: 100, t: '2.1', l: 7200 }, { row: 22, w: 100, h: 100, t: '2.1', l: 8000 },
            { row: 24, w: 100, h: 100, t: '2.3', l: 5000 }, { row: 25, w: 100, h: 100, t: '2.3', l: 6000 }, { row: 26, w: 100, h: 100, t: '2.3', l: 7200 }, { row: 27, w: 100, h: 100, t: '2.3', l: 8000 },
            { row: 29, w: 100, h: 100, t: '3.0', l: 5000 }, { row: 30, w: 100, h: 100, t: '3.0', l: 6000 }, { row: 31, w: 100, h: 100, t: '3.0', l: 7200 }, { row: 32, w: 100, h: 100, t: '3.0', l: 8000 },
            { row: 34, w: 100, h: 100, t: '3.2', l: 6000 }, { row: 35, w: 100, h: 100, t: '3.2', l: 6200 }, { row: 36, w: 100, h: 100, t: '3.2', l: 7200 }, { row: 37, w: 100, h: 100, t: '3.2', l: 8000 }
        ];

        const getUnitWeight = (w, h, t) => {
            const dims = [parseInt(w), parseInt(h)].sort((a, b) => b - a);
            const key = `${dims[0]}-${dims[1]}-${t}`;
            return UNIT_WEIGHT_DATA[key] || 0;
        };

        // --- Helper Function: Parse Items from Grid ---
        const parseItemsFromGrid = (gridData, colMapping, defaultSpec, defaultThickness) => {
            const lenIdx = Object.keys(colMapping).find(key => colMapping[key] === 'length');
            const qtyIdx = Object.keys(colMapping).find(key => colMapping[key] === 'qty');
            if (!lenIdx || !qtyIdx) return [];
            const wIdx = Object.keys(colMapping).find(key => colMapping[key] === 'width');
            const hIdx = Object.keys(colMapping).find(key => colMapping[key] === 'height');
            const tIdx = Object.keys(colMapping).find(key => colMapping[key] === 'thickness');
            const markIdx = Object.keys(colMapping).find(key => colMapping[key] === 'marking');
            let items = []; let rowCounter = 0;
            gridData.forEach((row) => {
                let rawLen = row[lenIdx]?.trim().replace(/,/g, '');
                let rawQty = row[qtyIdx]?.trim().replace(/í°/g, '').replace(/,/g, '');
                if (!rawLen || !rawQty) return;
                let length = parseFloat(rawLen);
                const qty = parseInt(rawQty, 10);
                if (isNaN(length) || isNaN(qty) || qty <= 0) return;
                if (length < 20) length = Math.round(length * 1000); else length = Math.round(length);
                let w = wIdx ? row[wIdx]?.trim().replace(/[^0-9.]/g, '') : '';
                let h = hIdx ? row[hIdx]?.trim().replace(/[^0-9.]/g, '') : '';
                let t = tIdx ? row[tIdx]?.trim().replace(/[^0-9.]/g, '') : '';
                let marking = markIdx ? (row[markIdx]?.trim() || '') : '';
                if (!w) w = defaultSpec.split('*')[0] || '100';
                if (!h) h = defaultSpec.split('*')[1] || '100';
                if (!t) t = defaultThickness;
                const dims = [parseInt(w), parseInt(h)].sort((a, b) => b - a);
                const specKey = `${dims[0]}*${dims[1]} ${t}T`;
                items.push({ id: rowCounter++, length, qty, marking, specKey, w: dims[0], h: dims[1], t: t });
            });
            return items;
        };

        // --- Excel Export Modal ---
        const ExcelExportModal = ({ isOpen, onClose, onConfirm, dongs }) => {
            if (!isOpen) return null;
            const [targetType, setTargetType] = useState('current');
            const [modeType, setModeType] = useState('min_rows');
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
                    <div className="bg-white rounded-xl shadow-2xl p-6 w-96 modal-fade-in relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"><X size={20} /></button>
                        <h3 className="text-xl font-bold mb-6 flex items-center gap-2"><FileDown className="text-green-600" /> ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</h3>
                        <div className="space-y-6">
                            <div>
                                <label className="block text-sm font-bold text-gray-700 mb-2">ì €ì¥ ëŒ€ìƒ</label>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setTargetType('current')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'current' ? 'border-green-500 bg-green-50 text-green-700' : 'border-gray-200 hover:bg-gray-50'}`}>í˜„ì¬ ë™ë§Œ</button>
                                    <button onClick={() => setTargetType('all')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'all' ? 'border-green-500 bg-green-50 text-green-700' : 'border-gray-200 hover:bg-gray-50'}`}>ì „ì²´ ë™</button>
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm font-bold text-gray-700 mb-2">ì €ì¥ ë²„ì „</label>
                                <div className="space-y-2">
                                    <button onClick={() => setModeType('min_rows')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_rows' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘  ì‘ì—… í¸ì˜ (Work Convenience)</span>{modeType === 'min_rows' && <Check size={16} />}
                                    </button>
                                    <button onClick={() => setModeType('min_loss')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_loss' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘¡ LOSS ìµœì†Œí™” (ìì¬ ì ˆì•½)</span>{modeType === 'min_loss' && <Check size={16} />}
                                    </button>
                                    <button onClick={() => setModeType('manual_result')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'manual_result' ? 'border-purple-500 bg-purple-50 text-purple-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘¢ ìˆ˜ë™ ì‘ì„± ê²°ê³¼</span>{modeType === 'manual_result' && <Check size={16} />}
                                    </button>
                                    <button onClick={() => setModeType('both')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'both' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                        <span>â‘£ ìë™ ê³„ì‚° (ì‘ì—…+LOSS ë‘˜ ë‹¤)</span>{modeType === 'both' && <Check size={16} />}
                                    </button>
                                </div>
                            </div>
                        </div>
                        <button onClick={() => onConfirm(targetType, modeType)} className="w-full mt-8 bg-green-600 text-white py-3 rounded-xl font-bold shadow-lg hover:bg-green-700 transition flex justify-center items-center gap-2"><FileDown size={18} /> ë‹¤ìš´ë¡œë“œ ì‹œì‘</button>
                    </div>
                </div>
            );
        };

        // --- Stock Deduct Modal ---
        const StockDeductModal = ({ isOpen, onClose, onConfirm, dongs, isLoggedIn, handleLogin }) => {
            if (!isOpen) return null;
            const [targetType, setTargetType] = useState('current');
            const [modeType, setModeType] = useState('min_rows');

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
                    <div className="bg-white rounded-xl shadow-2xl p-6 w-96 modal-fade-in relative">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"><X size={20} /></button>
                        <h3 className="text-xl font-bold mb-6 flex items-center gap-2"><Cloud className="text-red-500" /> ì¬ê³  ì°¨ê° (êµ¬ê¸€ ì‹œíŠ¸)</h3>
                        
                        {!isLoggedIn ? (
                            <div className="text-center py-6">
                                <p className="text-sm text-gray-500 mb-4">ì¬ê³ ë¥¼ ì°¨ê°í•˜ë ¤ë©´ êµ¬ê¸€ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
                                <button onClick={handleLogin} className="bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition">êµ¬ê¸€ ë¡œê·¸ì¸</button>
                            </div>
                        ) : (
                            <div className="space-y-6">
                                <div>
                                    <label className="block text-sm font-bold text-gray-700 mb-2">ì°¨ê° ëŒ€ìƒ</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => setTargetType('current')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'current' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 hover:bg-gray-50'}`}>í˜„ì¬ ë™ë§Œ</button>
                                        <button onClick={() => setTargetType('all')} className={`p-3 rounded-lg border text-sm font-bold flex items-center justify-center gap-2 transition ${targetType === 'all' ? 'border-red-500 bg-red-50 text-red-700' : 'border-gray-200 hover:bg-gray-50'}`}>ì „ì²´ ë™</button>
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-bold text-gray-700 mb-2">ì‚¬ìš©í•  CP ë²„ì „</label>
                                    <div className="space-y-2">
                                        <button onClick={() => setModeType('min_rows')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_rows' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                            <span>â‘  ì‘ì—… í¸ì˜ (Work Convenience)</span>{modeType === 'min_rows' && <Check size={16} />}
                                        </button>
                                        <button onClick={() => setModeType('min_loss')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'min_loss' ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                            <span>â‘¡ LOSS ìµœì†Œí™” (ìì¬ ì ˆì•½)</span>{modeType === 'min_loss' && <Check size={16} />}
                                        </button>
                                        <button onClick={() => setModeType('manual_result')} className={`w-full p-3 rounded-lg border text-left text-sm font-medium transition flex justify-between items-center ${modeType === 'manual_result' ? 'border-purple-500 bg-purple-50 text-purple-700' : 'border-gray-200 hover:bg-gray-50'}`}>
                                            <span>â‘¢ ìˆ˜ë™ ì‘ì„± ê²°ê³¼</span>{modeType === 'manual_result' && <Check size={16} />}
                                        </button>
                                    </div>
                                </div>
                                <button onClick={() => onConfirm(targetType, modeType)} className="w-full mt-8 bg-red-600 text-white py-3 rounded-xl font-bold shadow-lg hover:bg-red-700 transition flex justify-center items-center gap-2"><Cloud size={18} /> ì°¨ê° ì‹¤í–‰</button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const Sidebar = memo(({ viewMode, setViewMode, projectInfo, setProjectInfo, isNoDongMode, setIsNoDongMode }) => {
            const handleTextChange = useCallback((e, field) => setProjectInfo(prev => ({ ...prev, [field]: e.target.value })), [setProjectInfo]);
            const handleCheckChange = useCallback((e, field) => setProjectInfo(prev => ({ ...prev, [field]: e.target.checked })), [setProjectInfo]);

            return (
                <div id="sidebar" className="w-64 bg-white border-r border-gray-200 h-screen flex flex-col fixed left-0 top-0 z-30 print:hidden">
                    <div className="p-6 border-b">
                        <h1 className="text-xl font-bold flex items-center gap-2 text-blue-700"><Calculator className="text-blue-600" /> Smart CP</h1>
                        <p className="text-xs text-gray-400 mt-1">Ver 11.3.1 (Qty Comma Fix)</p>
                    </div>
                    <div className="p-4 space-y-4 flex-1 overflow-y-auto">
                        <div className="space-y-2">
                            <label className="text-xs font-bold text-gray-500">í”„ë¡œì íŠ¸ ì •ë³´</label>
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="ì—…ì²´ëª…" value={projectInfo.company} onChange={e => handleTextChange(e, 'company')} />
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="í˜„ì¥ëª…" value={projectInfo.site} onChange={e => handleTextChange(e, 'site')} />
                            <input className="w-full p-2 border rounded text-sm bg-gray-50 focus:bg-white transition" placeholder="ê¸°íƒ€ì‚¬í•­ (ë©”ëª¨)" value={projectInfo.note} onChange={e => handleTextChange(e, 'note')} />
                            <div className="flex flex-col gap-1 mt-2">
                                <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={projectInfo.isIronBanding} onChange={e => handleCheckChange(e, 'isIronBanding')} /> ì² ë°´ë”© ë™í‘œê¸°</label>
                                <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={projectInfo.isUnder1Ton} onChange={e => handleCheckChange(e, 'isUnder1Ton')} /> 1í†¤ ë¯¸ë§Œ ë°´ë”©</label>
                                <label className="flex items-center gap-2 text-xs cursor-pointer font-bold text-blue-600"><input type="checkbox" checked={isNoDongMode} onChange={e => setIsNoDongMode(e.target.checked)} /> ë™ í‘œê¸° ì—†ìŒ (ë‹¨ì¼ CP)</label>
                            </div>
                        </div>
                        <div className="space-y-1">
                            <button onClick={() => setViewMode('input')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode === 'input' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><FileSpreadsheet size={16} /> ë°ì´í„° ì…ë ¥</button>
                            <button onClick={() => setViewMode('result')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode === 'result' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><Calculator size={16} /> CP ìë™ ê³„ì‚°</button>
                            <button onClick={() => setViewMode('manual')} className={`w-full text-left px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 ${viewMode === 'manual' ? 'bg-blue-50 text-blue-700' : 'text-gray-600 hover:bg-gray-50'}`}><Edit3 size={16} /> CP ì§ì ‘ ì‘ì„±</button>
                        </div>
                    </div>
                </div>
            );
        });

        const DongTabs = ({ dongs, currentDong, setCurrentDong, addDong, deleteDong, renameDong }) => (
            <div className="flex gap-2 mb-4 overflow-x-auto pb-2 border-b items-center print:hidden">
                {dongs.map(dong => (
                    <div key={dong} className="relative group">
                        <button onDoubleClick={() => renameDong(dong)} onClick={() => setCurrentDong(dong)} className={`px-4 py-2 rounded-t-lg font-bold text-sm whitespace-nowrap transition pr-8 ${currentDong === dong ? 'bg-white border-x border-t border-gray-200 text-blue-600 relative top-[1px]' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}>
                            <span className="flex items-center gap-2"><Building size={14} /> {dong}</span>
                        </button>
                        <div className={`absolute right-1 top-1/2 -translate-y-1/2 flex gap-1 ${currentDong === dong ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'} transition`}>
                            <button onClick={(e) => { e.stopPropagation(); deleteDong(dong); }} className="p-0.5 text-gray-400 hover:text-red-500 rounded"><Trash2 size={10} /></button>
                        </div>
                    </div>
                ))}
                <button onClick={addDong} className="px-3 py-2 text-gray-400 hover:text-blue-600 font-bold text-sm bg-gray-50 rounded hover:bg-blue-50 transition"><Plus size={16} /></button>
            </div>
        );

        // --- Manual CP View ---
        const ManualCPView = ({ dongs, currentDong, setCurrentDong, addDong, deleteDong, renameDong, projectInfo, manualData, setManualData, parsedItems, onConvert, isNoDongMode }) => {
            const rows = manualData[currentDong] || [];
            const [hideEmpty, setHideEmpty] = useState(false);
            const updateRows = (newRows) => { setManualData(prev => ({ ...prev, [currentDong]: newRows })); };
            const addStockRow = () => { const lastRow = rows.length > 0 ? rows[rows.length - 1] : { t: '2.1', w: '100', h: '100', l: 6000, qty: 1 }; const newRow = { id: Date.now(), t: lastRow.t, w: lastRow.w, h: lastRow.h, l: lastRow.l, qty: 1, cuts: Array(8).fill().map(() => ({ l: '', count: '', marking: '' })) }; updateRows([...rows, newRow]); };
            const handleStockChange = (rIdx, field, val) => { const newRows = [...rows]; newRows[rIdx] = { ...newRows[rIdx], [field]: val }; updateRows(newRows); };
            const handleCutChange = (rIdx, cIdx, field, val) => { const newRows = [...rows]; const newCuts = [...newRows[rIdx].cuts]; newCuts[cIdx] = { ...newCuts[cIdx], [field]: val }; newRows[rIdx] = { ...newRows[rIdx], cuts: newCuts }; updateRows(newRows); };
            const removeStockRow = (rIdx) => { if (confirm('ì´ ì›ë³¸ í–‰ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) { const newRows = rows.filter((_, i) => i !== rIdx); updateRows(newRows); } };
            const sortRowsByLength = () => { const newRows = [...rows].sort((a, b) => { if (a.t !== b.t) return parseFloat(b.t) - parseFloat(a.t); if (a.w !== b.w) return parseFloat(b.w) - parseFloat(a.w); if (a.h !== b.h) return parseFloat(b.h) - parseFloat(a.h); return b.l - a.l; }); updateRows(newRows); };
            const requiredItems = useMemo(() => { const grouped = {}; (parsedItems || []).forEach(item => { const itemMarking = item.marking ? String(item.marking).trim() : ''; const key = `${item.t}|${item.w}|${item.h}|${item.length}|${itemMarking}`; if (!grouped[key]) grouped[key] = { ...item, marking: itemMarking, required: 0, used: 0 }; grouped[key].required += item.qty; }); return Object.values(grouped).sort((a, b) => b.length - a.length); }, [parsedItems]);
            const remainingItems = useMemo(() => { const status = JSON.parse(JSON.stringify(requiredItems)); (rows || []).forEach(row => { if (Array.isArray(row.cuts)) { row.cuts.forEach(cut => { if (cut.l && cut.count) { const cutLen = parseFloat(cut.l); const totalCutCount = parseInt(cut.count) * parseInt(row.qty || 0); const cutMarking = cut.marking ? String(cut.marking).trim() : ''; const match = status.find(item => Math.abs(item.length - cutLen) < 0.1 && (item.marking || '') === cutMarking && item.t == row.t && item.w == row.w && item.h == row.h); if (match) { match.used += totalCutCount; } } }); } }); return status; }, [requiredItems, rows]);

            return (
                <div className="animate-fade-in pb-20 flex gap-4 h-[calc(100vh-100px)]">
                    <div className="flex-1 bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-hidden">
                        <div className="p-3 border-b bg-gray-50 flex justify-between items-center shrink-0">
                            <h2 className="font-bold flex items-center gap-2"><Edit3 size={18} className="text-blue-600" /> CP ì§ì ‘ ì‘ì„± {isNoDongMode ? '' : `(${currentDong})`}</h2>
                            <div className="flex gap-2">
                                <button onClick={() => setHideEmpty(!hideEmpty)} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 border ${hideEmpty ? 'bg-blue-100 text-blue-700 border-blue-200' : 'bg-white text-gray-500 border-gray-300'}`}>{hideEmpty ? <EyeOff size={14} /> : <Eye size={14} />} ë¹ˆì¹¸ {hideEmpty ? 'ë³´ì´ê¸°' : 'ìˆ¨ê¸°ê¸°'}</button>
                                <button onClick={sortRowsByLength} className="px-3 py-1.5 text-xs font-bold rounded bg-white border border-gray-300 text-gray-600 hover:bg-gray-50">ê¸¸ì´ìˆœ ì •ë ¬</button>
                                <button onClick={() => onConvert(rows)} className="px-3 py-1.5 text-xs font-bold rounded bg-blue-600 text-white hover:bg-blue-700 flex items-center gap-1"><Copy size={14} /> ê²°ê³¼ í™•ì¸ ë° ì—‘ì…€ ì €ì¥</button>
                            </div>
                        </div>
                        <div className="flex-1 overflow-auto custom-scrollbar bg-white p-4">
                            {!isNoDongMode && <DongTabs dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} />}
                            <table className="w-full border-collapse text-xs text-center shadow-sm">
                                <thead className="sticky top-0 z-10">
                                    <tr className="bg-cyan-100 h-8 border-y border-gray-300 text-gray-700 font-bold">
                                        <th className="border w-10">ìˆœë²ˆ</th>
                                        <th className="border w-12">ë‘ê»˜</th>
                                        <th className="border w-12">ì¥ë³€</th>
                                        <th className="border w-12">ë‹¨ë³€</th>
                                        <th className="border w-16">ê¸¸ì´</th>
                                        <th className="border w-12">ìˆ˜ëŸ‰</th>
                                        <th className="border w-16 bg-blue-50">ê¸¸ì´</th>
                                        <th className="border w-12 bg-blue-50">ì»·íŒ…ìˆ˜</th>
                                        <th className="border w-12 bg-blue-50">ìˆ˜ëŸ‰</th>
                                        <th className="border bg-blue-50">ë§ˆí‚¹</th>
                                        <th className="border w-16">ë³¸ë‹¹LOSS</th>
                                        <th className="border w-20">ì´LOSS</th>
                                        <th className="border w-12">ë¹„ê³ </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {(rows || []).map((row, rIdx) => {
                                        const cuts = Array.isArray(row.cuts) ? row.cuts : [];
                                        const visibleCuts = hideEmpty ? cuts.filter(c => c.l && c.count) : cuts;
                                        const renderCuts = visibleCuts.length > 0 ? visibleCuts : (hideEmpty ? [] : cuts);
                                        const rowSpan = Math.max(1, renderCuts.length);
                                        const usedLength = cuts.reduce((acc, c) => acc + (parseFloat(c.l || 0) * parseFloat(c.count || 0)), 0);
                                        const lossPerBar = row.l - usedLength;
                                        const totalRowLoss = lossPerBar * row.qty;
                                        return (
                                            <React.Fragment key={row.id || rIdx}>
                                                {renderCuts.map((cut, cIdx) => {
                                                    const isFirst = cIdx === 0;
                                                    const cutQty = (parseInt(cut.count) * parseInt(row.qty)) || '';
                                                    return (
                                                        <tr key={cIdx} className="border-b border-gray-200 hover:bg-gray-50 h-8">
                                                            {isFirst && (<><td rowSpan={rowSpan} className="border bg-yellow-100 font-bold relative group">{rIdx + 1}<button onClick={() => removeStockRow(rIdx)} className="absolute left-0 top-0 text-red-400 opacity-0 group-hover:opacity-100 p-0.5"><Trash2 size={10} /></button></td><td rowSpan={rowSpan} className="border bg-yellow-50 p-0"><input className="input-cell bg-yellow-50" value={row.t} onChange={e => handleStockChange(rIdx, 't', e.target.value)} /></td><td rowSpan={rowSpan} className="border bg-yellow-50 p-0"><input className="input-cell bg-yellow-50" value={row.w} onChange={e => handleStockChange(rIdx, 'w', e.target.value)} /></td><td rowSpan={rowSpan} className="border bg-yellow-50 p-0"><input className="input-cell bg-yellow-50" value={row.h} onChange={e => handleStockChange(rIdx, 'h', e.target.value)} /></td><td rowSpan={rowSpan} className="border bg-yellow-50 p-0"><input type="number" className="input-cell bg-yellow-50 font-bold" value={row.l} onChange={e => handleStockChange(rIdx, 'l', e.target.value)} /></td><td rowSpan={rowSpan} className="border bg-yellow-50 p-0"><input type="number" className="input-cell bg-yellow-50" value={row.qty} onChange={e => handleStockChange(rIdx, 'qty', e.target.value)} /></td></>)}
                                                            <td className="border p-0"><input type="number" className="input-cell" value={cut.l} onChange={e => handleCutChange(rIdx, cuts.indexOf(cut), 'l', e.target.value)} /></td><td className="border p-0"><input type="number" className="input-cell" value={cut.count} onChange={e => handleCutChange(rIdx, cuts.indexOf(cut), 'count', e.target.value)} /></td><td className="border bg-gray-50 text-gray-500">{cutQty ? cutQty.toLocaleString() : ''}</td><td className="border p-0"><input className="input-cell text-left px-1" value={cut.marking} onChange={e => handleCutChange(rIdx, cuts.indexOf(cut), 'marking', e.target.value)} /></td>
                                                            {isFirst && (<><td rowSpan={rowSpan} className={`border font-bold ${lossPerBar >= 650 ? 'text-blue-600' : (lossPerBar < 150 ? 'text-red-500' : 'text-gray-700')}`}>{lossPerBar.toLocaleString()}</td><td rowSpan={rowSpan} className="border text-gray-600">{totalRowLoss.toLocaleString()}</td><td rowSpan={rowSpan} className="border"></td></>)}
                                                        </tr>
                                                    );
                                                })}
                                                <tr className="h-1 bg-gray-100 border-t border-gray-300"><td colSpan="13"></td></tr>
                                            </React.Fragment>
                                        );
                                    })}
                                </tbody>
                            </table>
                            <button onClick={addStockRow} className="w-full mt-4 py-3 border-2 border-dashed border-gray-300 rounded-lg text-gray-400 hover:border-blue-400 hover:text-blue-500 font-bold transition">+ ì›ë³¸ ì¶”ê°€</button>
                        </div>
                    </div>
                    <div className="w-80 flex flex-col gap-4">
                        <div className="flex-1 bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-hidden"><div className="p-2 bg-gray-800 text-white font-bold text-sm text-center">ê²¬ì  ë¬¼ëŸ‰ (í•„ìš” ìì¬)</div><div className="flex-1 overflow-auto custom-scrollbar p-2"><table className="w-full text-xs text-center border-collapse"><thead className="sticky top-0 bg-white shadow-sm"><tr className="bg-gray-100 border-b"><th className="p-1">ê·œê²©(T/W/H)</th><th className="p-1">ê¸¸ì´</th><th className="p-1">ìˆ˜ëŸ‰</th><th className="p-1">ë§ˆí‚¹</th></tr></thead><tbody>{requiredItems.map((item, i) => (<tr key={i} className="border-b hover:bg-gray-50"><td className="p-1">{item.t}/{item.w}/{item.h}</td><td className="p-1 font-bold">{item.length}</td><td className="p-1">{item.required}</td><td className="p-1 text-left truncate max-w-[80px]" title={item.marking}>{item.marking}</td></tr>))}</tbody></table></div></div>
                        <div className="flex-1 bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-hidden"><div className="p-2 bg-blue-600 text-white font-bold text-sm text-center">ë‚¨ì€ ë¬¼ëŸ‰ (ì‹¤ì‹œê°„)</div><div className="flex-1 overflow-auto custom-scrollbar p-2"><table className="w-full text-xs text-center border-collapse"><thead className="sticky top-0 bg-white shadow-sm"><tr className="bg-blue-50 border-b border-blue-200"><th className="p-1">ê·œê²©(T/W/H)</th><th className="p-1">ê¸¸ì´</th><th className="p-1">í•„ìš”</th><th className="p-1">ì”ì—¬</th><th className="p-1">ë§ˆí‚¹</th></tr></thead><tbody>{remainingItems.map((item, i) => { const remaining = item.required - item.used; const isDone = remaining <= 0; return (<tr key={i} className={`border-b ${isDone ? 'bg-gray-100 text-gray-400' : 'hover:bg-blue-50'}`}><td className="p-1">{item.t}/{item.w}/{item.h}</td><td className="p-1 font-bold">{item.length}</td><td className="p-1">{item.required}</td><td className={`p-1 font-bold ${remaining < 0 ? 'text-red-500' : (remaining === 0 ? 'text-green-500' : 'text-black')}`}>{remaining}</td><td className="p-1 text-left truncate max-w-[60px]" title={item.marking}>{item.marking}</td></tr>); })}</tbody></table></div></div>
                    </div>
                </div>
            );
        };

        // --- Input View ---
        const InputView = ({
            currentDong, dongs, setCurrentDong, addDong, deleteDong, renameDong,
            data, updateCurrentData, activeTab, setActiveTab, customStocks, setCustomStocks,
            processGridData, handlePaste, runAllDongs, globalSettings,
            isUserStockMode, setIsUserStockMode, userStockList, setUserStockList,
            setViewMode, isCalculating, isNoDongMode,
            handleFetchStock, isGapiReady, isLoggedIn, handleLogin
        }) => {
            const [inputMode, setInputMode] = useState('sales');
            const [newStd, setNewStd] = useState({ w: '100', h: '100', t: '2.1', length: 6000, qty: 10 });
            const [newRem, setNewRem] = useState({ w: '100', h: '100', t: '2.1', length: 0, qty: 1 });

            useEffect(() => { if (inputMode === 'sales') { updateCurrentData({ colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' } }); } else { updateCurrentData({ colMapping: { 2: 'width', 3: 'height', 4: 'thickness', 5: 'length', 7: 'qty', 8: 'marking' } }); } }, [inputMode]);
            const getSpecOptions = () => { const options = []; Object.keys(globalSettings).forEach(key => { if (Array.isArray(globalSettings[key])) { if (key !== "default") options.push({ label: key, value: key + "|2.1" }); } else { Object.keys(globalSettings[key]).forEach(subKey => { options.push({ label: `${key} ${subKey}T`, value: `${key}|${subKey}` }); }); } }); return options; };
            const getStandardLengthsForInput = (w, h, t) => { const dims = [parseInt(w), parseInt(h)].sort((a, b) => b - a); const specKey = `${dims[0]}x${dims[1]}`; const thickStr = String(t).trim(); const settings = globalSettings; if (settings[specKey]) { if (settings[specKey][thickStr]) return settings[specKey][thickStr]; if (thickStr === '2.3' && settings[specKey]['2.1']) return settings[specKey]['2.1']; if (settings[specKey]['all']) return settings[specKey]['all']; } return settings["default"] || []; };
            const handleCellChange = (rIdx, cIdx, val) => { const newData = [...data.gridData]; newData[rIdx][cIdx] = val; updateCurrentData({ gridData: newData }); };
            const handleAddUserStock = (type) => { const stock = type === 'std' ? newStd : newRem; if (!stock.length || stock.length <= 0 || !stock.qty || stock.qty <= 0) { alert("ê¸¸ì´ì™€ ìˆ˜ëŸ‰ì„ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•˜ì„¸ìš”."); return; } setUserStockList([...userStockList, { ...stock, id: Date.now(), type }]); };

            return (
                <div className="animate-fade-in pb-16 relative">
                    {isCalculating && (<div className="absolute inset-0 bg-white/80 z-50 flex flex-col items-center justify-center"><div className="loader mb-4"></div><p className="text-blue-600 font-bold animate-pulse">ìµœì ì˜ ì»·íŒ… íŒ¨í„´ì„ ê³„ì‚° ì¤‘ì…ë‹ˆë‹¤...</p></div>)}
                    <div className="flex justify-between items-end mb-2">
                        <h2 className="text-lg font-bold text-gray-800">ë°ì´í„° ì…ë ¥ {isNoDongMode ? '' : `(${currentDong})`}</h2>
                        <div className="flex gap-2">
                            <button onClick={runAllDongs} className="bg-gray-800 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-gray-900 flex gap-2 items-center transition"><Layers size={16} /> ì „ì²´ ë™ ê³„ì‚°</button>
                            <button onClick={processGridData} className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-blue-700 flex gap-2 items-center transition"><Calculator size={16} /> í˜„ì¬ ë™ ê³„ì‚°</button>
                            <button onClick={() => setViewMode('manual')} className="bg-white border border-blue-600 text-blue-600 px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-blue-50 flex gap-2 items-center transition"><Edit3 size={16} /> CP ì§ì ‘ ì‘ì„±</button>
                        </div>
                    </div>
                    {!isNoDongMode && <DongTabs dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} />}

                    <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                        <div className="lg:col-span-1 space-y-4">
                            <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-3 flex items-center gap-2 text-sm"><Settings size={16} /> ì…ë ¥ ì–‘ì‹ ì„ íƒ</h3>
                                <div className="flex bg-gray-100 p-1 rounded-lg">
                                    <button onClick={() => setInputMode('sales')} className={`flex-1 py-2 text-xs font-bold rounded ${inputMode === 'sales' ? 'bg-white shadow text-blue-600' : 'text-gray-500'}`}>ì˜ì—… (ê¸°ë³¸)</button>
                                    <button onClick={() => setInputMode('design')} className={`flex-1 py-2 text-xs font-bold rounded ${inputMode === 'design' ? 'bg-white shadow text-blue-600' : 'text-gray-500'}`}>ì„¤ê³„ (ìƒì„¸)</button>
                                </div>
                            </div>

                            <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-2 flex items-center gap-2 text-sm"><Cloud size={16} /> êµ¬ê¸€ ì‹œíŠ¸ ì¬ê³  ì—°ë™</h3>
                                {isGapiReady ? (
                                    !isLoggedIn ? (
                                        <button onClick={handleLogin} className="w-full bg-blue-100 text-blue-700 px-4 py-2 rounded-lg text-xs font-bold hover:bg-blue-200 transition mb-2">êµ¬ê¸€ ë¡œê·¸ì¸ (ì¬ê³  ì—°ë™)</button>
                                    ) : (
                                        <div className="space-y-2">
                                            <div className="text-xs text-green-600 font-bold mb-1">âœ“ êµ¬ê¸€ ê³„ì • ì—°ë™ë¨</div>
                                            <button onClick={handleFetchStock} className="w-full bg-green-600 text-white px-4 py-2 rounded-lg text-xs font-bold shadow hover:bg-green-700 transition">ğŸ“¥ ì¬ê³  ë¶ˆëŸ¬ì˜¤ê¸° (ì‚¬ìš©)</button>
                                        </div>
                                    )
                                ) : (
                                    <div className="text-xs text-gray-500">Google API ì´ˆê¸°í™” ì¤‘...</div>
                                )}
                            </div>

                            <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-2 flex items-center gap-2 text-sm"><Settings size={16} /> ìì¬ ì„¤ì •</h3>
                                <div className="mb-3 border-b pb-3">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" className="w-4 h-4 text-blue-600" checked={isUserStockMode} onChange={e => setIsUserStockMode(e.target.checked)} />
                                        <span className="text-sm font-bold text-gray-800">ì œí•œëœ ìì¬ë¡œë§Œ ê³„ì‚° (Inventory)</span>
                                    </label>
                                    <p className="text-[10px] text-gray-400 mt-1 pl-6">ì²´í¬ ì‹œ, ì•„ë˜ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ìì¬ë¡œë§Œ CPë¥¼ ì§­ë‹ˆë‹¤.</p>
                                </div>
                                {isUserStockMode ? (
                                    <div className="space-y-3">
                                        <div className="bg-blue-50 p-2 rounded border border-blue-100"><div className="text-xs font-bold text-blue-700 mb-1">í‘œì¤€ ìì¬ ì¶”ê°€</div><div className="flex gap-1 mb-1"><select className="flex-1 p-1 border rounded text-xs" value={`${newStd.w}*${newStd.h}|${newStd.t}`} onChange={e => { const val = e.target.value; if (!val) return; const [dim, t] = val.split('|'); const parts = dim.replace('x', '*').split('*'); setNewStd({ ...newStd, w: parts[0], h: parts[1], t: t, length: getStandardLengthsForInput(parts[0], parts[1], t)[0] }); }}>{getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x', '*')}>{opt.label}</option>)}</select><select className="w-20 p-1 border rounded text-xs" value={newStd.length} onChange={e => setNewStd({ ...newStd, length: +e.target.value })}>{getStandardLengthsForInput(newStd.w, newStd.h, newStd.t).map(l => <option key={l} value={l}>{l}</option>)}</select></div><div className="flex gap-1"><input type="number" className="flex-1 p-1 border rounded text-xs" placeholder="ìˆ˜ëŸ‰" value={newStd.qty} onChange={e => setNewStd({ ...newStd, qty: +e.target.value })} /><button onClick={() => handleAddUserStock('std')} className="px-2 bg-blue-600 text-white rounded text-xs font-bold">+</button></div></div>
                                        <div className="bg-gray-50 p-2 rounded border border-gray-200"><div className="text-xs font-bold text-gray-700 mb-1">ì”ì¬/ê¸°íƒ€ ìì¬ ì¶”ê°€</div><div className="flex gap-1 mb-1"><select className="w-full p-1 border rounded text-xs" value={`${newRem.w}*${newRem.h}|${newRem.t}`} onChange={e => { const val = e.target.value; if (!val) return; const [dim, t] = val.split('|'); const parts = dim.replace('x', '*').split('*'); setNewRem({ ...newRem, w: parts[0], h: parts[1], t: t }); }}>{getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x', '*')}>{opt.label}</option>)}</select></div><div className="flex gap-1"><input type="number" className="flex-1 p-1 border rounded text-xs" placeholder="ê¸¸ì´" value={newRem.length || ''} onChange={e => setNewRem({ ...newRem, length: +e.target.value })} /><input type="number" className="w-12 p-1 border rounded text-xs" placeholder="ìˆ˜ëŸ‰" value={newRem.qty} onChange={e => setNewRem({ ...newRem, qty: +e.target.value })} /><button onClick={() => handleAddUserStock('rem')} className="px-2 bg-gray-600 text-white rounded text-xs font-bold">+</button></div></div>
                                        <div className="max-h-40 overflow-y-auto border-t pt-2 space-y-1">{userStockList.length === 0 && <p className="text-xs text-gray-400 text-center">ì¶”ê°€ëœ ìì¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>}{userStockList.map(item => (<div key={item.id} className="flex justify-between items-center text-xs bg-white p-1 rounded border"><span>{item.type === 'std' ? 'ğŸŸ¦' : 'â¬œ'} {item.w}*{item.h} {item.t}T - <b>{item.length}</b> ({item.qty}ë³¸)</span><button onClick={() => setUserStockList(userStockList.filter(x => x.id !== item.id))} className="text-red-500"><Trash2 size={12} /></button></div>))}</div>
                                    </div>
                                ) : (
                                    <div className="space-y-3">
                                        <div><label className="text-xs font-bold text-gray-500">ê¸°ë³¸ ê·œê²©</label><div className="flex gap-2 mt-1"><select value={data.spec} onChange={e => updateCurrentData({ spec: e.target.value })} className="flex-1 p-1.5 border rounded text-sm bg-gray-50"><option>100*100</option><option>75*75</option><option>100*50</option><option>50*50</option></select><select value={data.thickness} onChange={e => updateCurrentData({ thickness: e.target.value })} className="w-20 p-1.5 border rounded text-sm bg-gray-50"><option>2.1</option><option>2.3</option><option>3.0</option><option>3.2</option></select></div></div>
                                        <div className="pt-2 border-t"><div className="flex bg-gray-100 p-1 rounded-lg mb-2"><button onClick={() => setActiveTab('standard')} className={`flex-1 py-1 text-xs font-bold rounded ${activeTab === 'standard' ? 'bg-white shadow text-blue-600' : 'text-gray-500'}`}>í‘œì¤€</button><button onClick={() => setActiveTab('custom')} className={`flex-1 py-1 text-xs font-bold rounded ${activeTab === 'custom' ? 'bg-white shadow text-blue-600' : 'text-gray-500'}`}>ì”ì¬(ê³µí†µ)</button></div>{activeTab === 'custom' && (<div className="space-y-2">{customStocks.map((s, i) => (<div key={i} className="flex flex-col gap-1 p-2 bg-gray-50 rounded border"><div className="flex gap-1 mb-1"><select className="w-full p-1 border rounded text-xs bg-white" value={`${s.w}*${s.h}|${s.t}`} onChange={e => { const val = e.target.value; if (val && val.includes('|')) { const [dim, t] = val.split('|'); const parts = dim.replace('x', '*').split('*'); const n = [...customStocks]; n[i].w = parts[0]; n[i].h = parts[1]; n[i].t = t; setCustomStocks(n); } }}><option value="">ê·œê²© ì„ íƒ</option>{getSpecOptions().map(opt => <option key={opt.value} value={opt.value.replace('x', '*')}>{opt.label}</option>)}</select></div><div className="flex gap-1 items-center"><input type="number" className="flex-1 p-1 border rounded text-xs" value={s.length} onChange={e => { const n = [...customStocks]; n[i].length = +e.target.value; setCustomStocks(n) }} placeholder="Length" /><input type="number" className="w-10 p-1 border rounded text-xs" value={s.qty} onChange={e => { const n = [...customStocks]; n[i].qty = +e.target.value; setCustomStocks(n) }} placeholder="Qty" /><button onClick={() => setCustomStocks(customStocks.filter((_, idx) => idx !== i))} className="text-red-400"><Trash2 size={14} /></button></div></div>))}<button onClick={() => setCustomStocks([...customStocks, { w: '100', h: '100', t: '2.1', length: 0, qty: 1 }])} className="w-full py-1 text-xs border border-dashed rounded text-blue-500 font-bold hover:bg-blue-50">+ ì¶”ê°€</button></div>)}</div>
                                    </div>
                                )}
                            </div>
                            <div className="p-3 bg-blue-50 rounded-lg text-xs text-blue-700">ğŸ’¡ <b>[ì‘ì—… í¸ì˜]</b> ëª¨ë“œëŠ” ì”ì¬ 150mm ì´í•˜(0 í¬í•¨) ë¶ˆê°€, 650mm ì´ˆê³¼ ê¸°í”¼, ë§ˆí‚¹ ë­‰ì¹˜ê¸°ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ í•©ë‹ˆë‹¤.</div>
                        </div>

                        <div className="lg:col-span-3 bg-white p-0 rounded-xl shadow-sm border border-gray-200 flex flex-col h-[700px] overflow-hidden">
                            <div className="p-3 border-b bg-gray-50 flex justify-between items-center"><span className="text-sm font-bold text-gray-600">ì—‘ì…€ ë¶™ì—¬ë„£ê¸° ì˜ì—­ (ìˆ˜ì • ê°€ëŠ¥)</span><button onClick={() => { updateCurrentData({ rawInput: '', gridData: [] }) }} className="text-xs text-red-500 hover:underline">ì´ˆê¸°í™”</button></div>
                            <div className="flex-1 overflow-auto custom-scrollbar relative bg-white">
                                {data.gridData.length === 0 ? (<div className="absolute inset-0 flex items-center justify-center"><textarea className="absolute inset-0 opacity-0 cursor-text" onPaste={handlePaste} autoFocus /><div className="text-center text-gray-400 pointer-events-none"><p className="text-2xl font-bold mb-2">Ctrl + V</p><p className="text-sm">ì—‘ì…€ í‘œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”</p></div></div>) : (<table className="w-full text-xs border-collapse"><thead className="sticky top-0 bg-white shadow-sm z-10"><tr><th className="p-1 border bg-gray-100 w-8 text-center text-gray-500">#</th>{data.gridData[0]?.map((_, cIdx) => (<th key={cIdx} className="p-1 border min-w-[80px]"><select className={`w-full p-1 border rounded text-xs font-bold ${['length', 'qty'].includes(data.colMapping[cIdx]) ? 'bg-blue-100 text-blue-700' : ['width', 'height', 'thickness'].includes(data.colMapping[cIdx]) ? 'bg-green-100 text-green-700' : 'bg-white text-gray-400'}`} value={data.colMapping[cIdx] || ''} onChange={e => updateCurrentData({ colMapping: { ...data.colMapping, [cIdx]: e.target.value } })}><option value="">- ë¬´ì‹œ -</option><option value="width">ê°€ë¡œ</option><option value="height">ì„¸ë¡œ</option><option value="thickness">ë‘ê»˜</option><option value="length">ğŸ“ ê¸¸ì´</option><option value="qty">ğŸ”¢ ìˆ˜ëŸ‰</option><option value="marking">ğŸ·ï¸ ë§ˆí‚¹</option></select></th>))}</tr></thead><tbody className="bg-white">{data.gridData.map((row, rIdx) => (<tr key={rIdx} className="hover:bg-blue-50"><td className="p-1 border text-center text-gray-400 bg-gray-50">{rIdx + 1}</td>{row.map((cell, cIdx) => (<td key={cIdx} className="border p-0"><input className="w-full h-full p-1 text-xs border-none focus:ring-2 focus:ring-blue-500 outline-none" value={cell} onChange={(e) => handleCellChange(rIdx, cIdx, e.target.value)} /></td>))}</tr>))}</tbody></table>)}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Result View ---
        const ResultView = ({ currentDong, dongs, setCurrentDong, addDong, deleteDong, renameDong, resultsByDong, runAllDongs, openExcelModal, openStockModal, setViewMode, setManualData, projectInfo, isNoDongMode }) => {
            const [resultTab, setResultTab] = useState('min_rows');
            const allResults = resultsByDong && currentDong ? resultsByDong[currentDong] : null;
            useEffect(() => { if (allResults && allResults['manual_result'] && !allResults['min_rows']) setResultTab('manual_result'); }, [allResults]);
            const results = allResults ? allResults[resultTab] : null;
            const specKeys = results ? Object.keys(results).sort() : [];
            let overallSeq = 1;
            const handleCopyToManual = () => {
                if (!results) return;
                const newRows = [];
                specKeys.forEach(specKey => {
                    const { plan } = results[specKey];
                    let w = "100", h = "100", t = "2.1";
                    try { const dims = specKey.split(' ')[0] || ""; const tPart = specKey.split(' ')[1] || ""; if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); else { w = dims; h = ""; } t = tPart.replace('T', ''); } catch (e) { }
                    let sortedPlan = [...plan]; sortedPlan.sort((a, b) => b.stockLength - a.stockLength);
                    sortedPlan.forEach((group) => {
                        const cuts = Array(8).fill().map(() => ({ l: '', count: '', marking: '' }));
                        group.parts.forEach((part, idx) => { if (idx < 8) cuts[idx] = { l: part.length, count: (part.totalQty / group.qty), marking: part.marking }; });
                        const newRow = { id: Date.now() + Math.random(), t: t, w: w, h: h, l: group.stockLength, qty: Math.floor(group.qty), cuts: cuts };
                        newRows.push(newRow);
                    });
                });
                setManualData(prev => ({ ...prev, [currentDong]: newRows }));
                setViewMode('manual');
                alert("í˜„ì¬ ë³´ê³  ìˆëŠ” ê²°ê³¼ê°€ 'CP ì§ì ‘ ì‘ì„±' í™”ë©´ìœ¼ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
            };

            const handlePdfDownload = () => { window.print(); };

            return (
                <div id="main-content" className="animate-fade-in pb-20 print:w-full print:m-0">
                    <div className="flex justify-between items-center mb-4 print:hidden">
                        <h2 className="text-lg font-bold text-gray-800">CP ìë™ ê²°ê³¼ {isNoDongMode ? '' : `(${currentDong})`}</h2>
                        <div className="flex gap-2">
                            <button onClick={handleCopyToManual} className="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-blue-600 transition flex items-center gap-2"><Copy size={16} /> ìˆ˜ì • (ê²°ê³¼ ë³µì‚¬)</button>
                            <button onClick={runAllDongs} className="bg-gray-800 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-gray-900 transition flex items-center gap-2"><Layers size={16} /> ì „ì²´ ë™ ê³„ì‚°</button>
                            <button onClick={openStockModal} className="bg-red-500 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-red-600 transition flex items-center gap-2"><Cloud size={16} /> ì¬ê³  ì°¨ê°</button>
                            <button onClick={openExcelModal} className="bg-green-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-green-700 flex items-center gap-2 transition"><FileDown size={16} /> ì—‘ì…€ ì €ì¥</button>
                            <button onClick={handlePdfDownload} className="bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-bold shadow hover:bg-red-700 flex items-center gap-2 transition"><FilePdf size={16} /> PDF ì €ì¥</button>
                        </div>
                    </div>
                    <div className="print:block hidden mb-4"><h1 className="text-2xl font-bold">â€» {projectInfo.company || 'ì—…ì²´ëª…'}({projectInfo.site || 'í˜„ì¥ëª…'}){isNoDongMode ? '' : ` - ${currentDong}`}</h1>{projectInfo.note && <p className="text-sm mt-1">ë¹„ê³ : {projectInfo.note}</p>}</div>
                    {!isNoDongMode && <DongTabs dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} />}
                    {(!allResults || !results) ? (<div className="text-center py-20 bg-white rounded-xl border border-dashed border-gray-300 text-gray-400"><p>ê³„ì‚°ëœ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p></div>) : (
                        <div>
                            <div className="flex mb-4 border-b print:hidden gap-2">
                                <button onClick={() => setResultTab('min_rows')} className={`px-6 py-3 font-bold text-sm ${resultTab === 'min_rows' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-500 hover:text-gray-700'}`}>â‘  ì‘ì—… í¸ì˜ (Work Convenience)</button>
                                <button onClick={() => setResultTab('min_loss')} className={`px-6 py-3 font-bold text-sm ${resultTab === 'min_loss' ? 'border-b-2 border-green-600 text-green-600' : 'text-gray-500 hover:text-gray-700'}`}>â‘¡ LOSS ìµœì†Œí™” (ìì¬ ì ˆì•½)</button>
                                {allResults['manual_result'] && <button onClick={() => setResultTab('manual_result')} className={`px-6 py-3 font-bold text-sm ${resultTab === 'manual_result' ? 'border-b-2 border-purple-600 text-purple-600' : 'text-gray-500 hover:text-gray-700'}`}>â‘¢ ìˆ˜ë™ ê³„ì‚° ê²°ê³¼</button>}
                            </div>
                            <div className="space-y-8 bg-white p-8 rounded-xl shadow-sm border border-gray-200 min-h-screen print:border-none print:p-0">
                                {specKeys.map((specKey, idx) => {
                                    const { plan, summary } = results[specKey];
                                    let w = "?", h = "?", t = "?"; try { const dims = specKey.split(' ')[0] || ""; const tPart = specKey.split(' ')[1] || ""; if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); else { w = dims; h = ""; } t = tPart.replace('T', ''); } catch (e) { }
                                    const totalBarsDisplay = summary.totalBars || plan.reduce((acc, p) => acc + Number(p.qty || 0), 0);
                                    const totalLossValue = summary.totalLoss !== undefined ? summary.totalLoss : plan.reduce((acc, p) => acc + (Number(p.remainder || 0) * Number(p.qty || 0)), 0);
                                    const displayLoss = Number(totalLossValue).toLocaleString();
                                    return (
                                        <div key={specKey || idx} className="break-before-page">
                                            <div className="flex items-center gap-3 mb-3 pb-2 border-b border-gray-100 print:border-none">
                                                <span className={`font-bold px-3 py-1 rounded text-sm print:hidden ${resultTab === 'min_rows' ? 'bg-blue-100 text-blue-700' : (resultTab === 'min_loss' ? 'bg-green-100 text-green-700' : 'bg-purple-100 text-purple-700')}`}>#{idx + 1} {resultTab === 'min_rows' ? 'ì‘ì—…í¸ì˜' : (resultTab === 'min_loss' ? 'LOSSìµœì†Œ' : 'ìˆ˜ë™ê²°ê³¼')}</span>
                                                <h3 className="font-bold text-xl text-gray-800">{specKey}</h3>
                                                <div className="text-xs text-gray-500 ml-auto flex gap-4 print:text-black"><span>ì´ ì›ë³¸: <b>{totalBarsDisplay}ë³¸</b></span><span>ì´ ì”ì¬: <b>{displayLoss}mm</b></span><span>ì”ì¬ìœ¨: {summary.lossRate}%</span></div>
                                            </div>
                                            <table className="w-full border-collapse text-center text-xs">
                                                <thead><tr className="bg-gray-100 text-gray-700 h-8 border-y border-gray-300 print:bg-gray-200"><th className="border-x border-gray-200 w-10">ìˆœë²ˆ</th><th className="border-x border-gray-200 w-12">ë‘ê»˜</th><th className="border-x border-gray-200 w-12">ì¥ë³€</th><th className="border-x border-gray-200 w-12">ë‹¨ë³€</th><th className="border-x border-gray-200 w-16">ì›ë³¸ê¸¸ì´</th><th className="border-x border-gray-200 w-12">ìˆ˜ëŸ‰</th><th className="border-x border-gray-200 w-16 bg-white font-bold text-blue-600 border-2 border-blue-100 print:border">ì»·íŒ…ê¸¸ì´</th><th className="border-x border-gray-200 w-12">ì»·íŒ…ìˆ˜</th><th className="border-x border-gray-200 w-12">ìˆ˜ëŸ‰</th><th className="border-x border-gray-200">ë§ˆí‚¹</th><th className="border-x border-gray-200 w-16">ë³¸ë‹¹LOSS</th><th className="border-x border-gray-200 w-20">ì´LOSS</th><th className="border-x border-gray-200 w-12">ë¹„ê³ </th></tr></thead>
                                                <tbody>
                                                    {plan.map((group, gIdx) => {
                                                        const rowClass = 'bg-white';
                                                        return group.parts.map((part, pIdx) => (
                                                            <tr key={`${gIdx}-${pIdx}`} className={`${rowClass} border-b border-gray-200 hover:bg-gray-50 transition print:bg-transparent`}>
                                                                {pIdx === 0 && (<><td rowSpan={group.parts.length} className="border-x border-gray-200 font-bold bg-gray-50 print:bg-transparent">{overallSeq++}</td><td rowSpan={group.parts.length} className="border-x border-gray-200">{t}</td><td rowSpan={group.parts.length} className="border-x border-gray-200">{w}</td><td rowSpan={group.parts.length} className="border-x border-gray-200">{h}</td><td rowSpan={group.parts.length} className="border-x border-gray-200 font-bold">{group.stockLength}</td><td rowSpan={group.parts.length} className="border-x border-gray-200">{Math.floor(group.qty)}</td></>)}
                                                                <td className="border-x border-gray-200 font-bold text-gray-800">{part.length}</td><td className="border-x border-gray-200">{(part.totalQty / group.qty)}</td><td className="border-x border-gray-200 font-bold">{Math.floor(part.totalQty)}</td><td className="border-x border-gray-200 text-left px-2 truncate max-w-[150px]">{part.marking}</td>
                                                                {pIdx === 0 && (<><td rowSpan={group.parts.length} className={`border-x border-gray-200 font-bold ${group.remainder >= 650 ? 'bg-[#FFCCBC] text-red-600' : ''}`}>{Number(group.remainder).toLocaleString()}</td><td rowSpan={group.parts.length} className="border-x border-gray-200 text-gray-500">{(Number(group.remainder) * Number(group.qty)).toLocaleString(undefined, { maximumFractionDigits: 0 })}</td><td rowSpan={group.parts.length} className="border-x border-gray-200"></td></>)}
                                                            </tr>
                                                        ));
                                                    })}
                                                </tbody>
                                            </table>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Main App ---
        function App() {
            const [user, setUser] = useState(null);
            const [viewMode, setViewMode] = useState('input');
            const [isFirebaseReady, setIsFirebaseReady] = useState(false);
            const [isExcelModalOpen, setIsExcelModalOpen] = useState(false);
            const [isStockModalOpen, setIsStockModalOpen] = useState(false);
            const [isCalculating, setIsCalculating] = useState(false);
            const [projectInfo, setProjectInfo] = useState({ company: '', site: '', note: '', isIronBanding: false, isUnder1Ton: false });
            const [dongs, setDongs] = useState(['1ë™']);
            const [currentDong, setCurrentDong] = useState('1ë™');
            const [isNoDongMode, setIsNoDongMode] = useState(false);

            const globalSettings = STANDARD_STOCKS;
            const [dongData, setDongData] = useState({ '1ë™': { rawInput: '', gridData: [], colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' }, parsedItems: [], spec: '100*100', thickness: '2.1' } });
            const [resultsByDong, setResultsByDong] = useState({});
            const [activeTab, setActiveTab] = useState('standard');
            const [customStocks, setCustomStocks] = useState([{ w: '100', h: '100', t: '2.1', length: 6000, qty: 10 }]);
            const [isUserStockMode, setIsUserStockMode] = useState(false);
            const [userStockList, setUserStockList] = useState([]);
            const [manualData, setManualData] = useState({});
            const getCurrentData = () => dongData[currentDong] || { rawInput: '', gridData: [], colMapping: {}, parsedItems: [], spec: '100*100', thickness: '2.1' };
            const updateCurrentData = (updates) => { setDongData(prev => ({ ...prev, [currentDong]: { ...prev[currentDong], ...updates } })); };
            const getStockLengths = (w, h, t) => { const dims = [parseInt(w), parseInt(h)].sort((a, b) => b - a); const specKey = `${dims[0]}x${dims[1]}`; const thickStr = String(t).trim(); const settings = globalSettings; if (settings[specKey]) { if (settings[specKey][thickStr]) return settings[specKey][thickStr]; if (thickStr === '2.3' && settings[specKey]['2.1']) return settings[specKey]['2.1']; if (settings[specKey]['all']) return settings[specKey]['all']; } return settings["default"] || []; };
            const initFirebase = async () => { if (!window.FirebaseSDK) return; try { const { initializeApp, getAuth } = window.FirebaseSDK; } catch (e) { console.warn(e); } };
            useEffect(() => { if (window.FirebaseSDK) initFirebase(); else window.addEventListener('firebase-sdk-ready', initFirebase); return () => window.removeEventListener('firebase-sdk-ready', initFirebase); }, []);
            const addDong = () => { const newDongName = prompt("ìƒˆ ë™ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:"); if (newDongName && !dongs.includes(newDongName)) { setDongs([...dongs, newDongName]); setDongData(prev => ({ ...prev, [newDongName]: { rawInput: '', gridData: [], colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' }, parsedItems: [], spec: '100*100', thickness: '2.1' } })); setCurrentDong(newDongName); } };
            const renameDong = (oldName) => { const newName = prompt(`'${oldName}'ì˜ ìƒˆ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:`, oldName); if (newName && newName !== oldName && !dongs.includes(newName)) { setDongs(prev => prev.map(d => d === oldName ? newName : d)); if (currentDong === oldName) setCurrentDong(newName); setDongData(prev => { const n = { ...prev }; n[newName] = n[oldName]; delete n[oldName]; return n; }); setResultsByDong(prev => { const n = { ...prev }; if (n[oldName]) { n[newName] = n[oldName]; delete n[oldName]; } return n; }); setManualData(prev => { const n = { ...prev }; n[newName] = n[oldName]; delete n[oldName]; return n; }); } };
            const deleteDong = (targetDong) => { if (dongs.length <= 1) { alert("ìµœì†Œ í•˜ë‚˜ì˜ ë™ì€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."); return; } if (confirm(`'${targetDong}'ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) { const newDongs = dongs.filter(d => d !== targetDong); setDongs(newDongs); if (currentDong === targetDong) setCurrentDong(newDongs[0]); setDongData(prev => { const n = { ...prev }; delete n[targetDong]; return n; }); setResultsByDong(prev => { const n = { ...prev }; delete n[targetDong]; return n; }); setManualData(prev => { const n = { ...prev }; delete n[targetDong]; return n; }); } };
            const handlePaste = (e) => { e.preventDefault(); const text = e.clipboardData.getData('text'); const rows = text.trim().split('\n').map(row => row.split('\t')); updateCurrentData({ rawInput: text, gridData: rows }); };

            // --- Google Sheets Logic (Auto Login Added) ---
            const [tokenClient, setTokenClient] = useState(null);
            const [isGapiReady, setIsGapiReady] = useState(false);
            const [isLoggedIn, setIsLoggedIn] = useState(false);

            useEffect(() => {
                const initGapi = () => { 
                    gapi.load('client', async () => { 
                        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] }); 
                        setIsGapiReady(true);
                        
                        // Auto-login check
                        const stored = localStorage.getItem('gapi_token');
                        if (stored) {
                            try {
                                const { token, expiry } = JSON.parse(stored);
                                if (Date.now() < expiry) {
                                    gapi.client.setToken(token);
                                    setIsLoggedIn(true);
                                    console.log('Auto-logged in via stored token');
                                } else {
                                    localStorage.removeItem('gapi_token'); // Clean up expired
                                }
                            } catch (e) {
                                console.error('Error parsing stored token', e);
                            }
                        }
                    }); 
                };
                const initGis = () => { 
                    const client = google.accounts.oauth2.initTokenClient({ 
                        client_id: CLIENT_ID, 
                        scope: SCOPES, 
                        callback: (tokenResponse) => { 
                            if (tokenResponse && tokenResponse.access_token) { 
                                // Save token with expiry (approx 1 hour)
                                const expiryTime = Date.now() + (tokenResponse.expires_in * 1000);
                                localStorage.setItem('gapi_token', JSON.stringify({
                                    token: tokenResponse,
                                    expiry: expiryTime
                                }));
                                setIsLoggedIn(true); 
                            } 
                        } 
                    }); 
                    setTokenClient(client); 
                };
                if (window.gapi) initGapi(); if (window.google) initGis();
            }, []);

            const handleLogin = () => { if (tokenClient) { tokenClient.requestAccessToken(); } };

            const handleFetchStock = async () => {
                try {
                    const response = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: SPREADSHEET_ID, range: 'Sheet1!AL5:AL37' });
                    const values = response.result.values;
                    if (!values || values.length === 0) { alert('ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì—ì„œ ì¬ê³  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
                    const fetchedStocks = [];
                    SHEET_ROW_MAP.forEach(map => {
                        const index = map.row - 5; 
                        if (values[index] && values[index][0]) {
                            // ğŸ’¡ ì‰¼í‘œ(,) ì œê±° ë¡œì§ ì¶”ê°€
                            const rawValue = String(values[index][0]).replace(/,/g, '');
                            const qty = parseInt(rawValue, 10);
                            
                            if (!isNaN(qty) && qty > 0) { fetchedStocks.push({ id: Date.now() + Math.random(), type: 'std', w: String(map.w), h: String(map.h), t: map.t, length: map.l, qty: qty }); }
                        }
                    });
                    setUserStockList(fetchedStocks); setIsUserStockMode(true); alert(`ì„±ê³µì ìœ¼ë¡œ ì¬ê³ ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.\nì´ ${fetchedStocks.length}ê°œ í’ˆëª©ì˜ ì¬ê³ ê°€ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                } catch (error) { console.error("Error fetching stock:", error); alert("ì¬ê³ ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\në¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•˜ê±°ë‚˜ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”."); }
            };

            const getColumnLetter = (colIndex) => {
                let temp, letter = '';
                while (colIndex > 0) { temp = (colIndex - 1) % 26; letter = String.fromCharCode(temp + 65) + letter; colIndex = (colIndex - temp - 1) / 26; }
                return letter;
            }

            const handleUpdateStock = async (targetScope, selectedMode) => {
                if (!isLoggedIn) { alert("êµ¬ê¸€ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
                // Calculate total used qty per spec
                const usedMap = {}; 
                const targets = targetScope === 'all' ? dongs : [currentDong];
                let hasData = false;

                targets.forEach(dName => {
                    if (resultsByDong[dName] && resultsByDong[dName][selectedMode]) {
                        const planResult = resultsByDong[dName][selectedMode];
                        hasData = true;
                        Object.keys(planResult).forEach(specKey => {
                            const { plan } = planResult[specKey];
                            plan.forEach(group => {
                                let w = "?", h = "?", t = "?"; try { const dims = specKey.split(' ')[0] || ""; const tPart = specKey.split(' ')[1] || ""; if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); else { w = dims; h = ""; } t = tPart.replace('T', ''); } catch (e) { }
                                const key = `${parseInt(w)}|${parseInt(h)}|${t.trim()}|${group.stockLength}`;
                                if(!usedMap[key]) usedMap[key] = 0;
                                usedMap[key] += Number(group.qty); // Accumulate quantity
                            });
                        });
                    }
                });

                if (!hasData) { alert("ì„ íƒí•œ ë²”ìœ„/ëª¨ë“œì— ëŒ€í•œ ê³„ì‚° ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."); return; }

                try {
                    const headerRange = 'Sheet1!H4:AK4';
                    const headerRes = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: SPREADSHEET_ID, range: headerRange });
                    const headerValues = headerRes.result.values || [[]];
                    const headers = headerValues[0];
                    let emptyColIndex = headers.length; 
                    if(emptyColIndex >= 30) { alert("ë” ì´ìƒ ê¸°ë¡í•  ë¹ˆ ì—´ì´ ì—†ìŠµë‹ˆë‹¤ (AKì—´ ì´ˆê³¼)."); return; }
                    const targetColNum = 8 + emptyColIndex; 
                    const targetColLetter = getColumnLetter(targetColNum);

                    const updateData = [];
                    const companyName = `${projectInfo.company || 'ì—…ì²´ë¯¸ìƒ'}(${projectInfo.site || 'í˜„ì¥ë¯¸ìƒ'})`;
                    updateData.push({ range: `Sheet1!${targetColLetter}4`, values: [[companyName]] });

                    SHEET_ROW_MAP.forEach(map => {
                        const key = `${map.w}|${map.h}|${map.t}|${map.l}`;
                        if(usedMap[key]) {
                            const usedQty = usedMap[key];
                            updateData.push({ range: `Sheet1!${targetColLetter}${map.row}`, values: [[-usedQty]] });
                        }
                    });

                    if(updateData.length === 1) { alert("ì°¨ê°í•  ì¬ê³  ì‚¬ìš©ëŸ‰ì´ ì—†ìŠµë‹ˆë‹¤ (í‘œì¤€ ìì¬ê°€ ì‚¬ìš©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤)."); return; }

                    await gapi.client.sheets.spreadsheets.values.batchUpdate({ spreadsheetId: SPREADSHEET_ID, resource: { data: updateData, valueInputOption: 'USER_ENTERED' } });
                    alert(`ì¬ê³  ì°¨ê°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\nì—´: ${targetColLetter}, í˜„ì¥ëª…: ${companyName}`);
                    setIsStockModalOpen(false);

                } catch (error) { console.error("Update Error:", error); alert("ì¬ê³  ì°¨ê°(ì €ì¥) ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + error.message); }
            };

            // *** OPTIMIZATION ENGINE (Modified to fix Marking Duplicate Bug) ***
            const solvePatternBased = (items, availableStocks, mode, strategy = 'mixed', randomize = false, stockLimits = {}) => {
                let inventory = {}; 
                // BUG FIX: Changed key from 'item.marking' to 'item.id' (unique per row)
                // This prevents items with same marking but different specs from overwriting each other.
                items.forEach(item => { 
                    const itemKey = item.id; // Unique Key
                    if (!inventory[itemKey]) { 
                        inventory[itemKey] = { qty: item.qty, length: item.length, specKey: item.specKey, t: item.t, w: item.w, h: item.h, marking: item.marking, initQty: item.qty, id: item.id }; 
                    } 
                });
                
                let markings = Object.keys(inventory); // 'markings' is now list of unique IDs
                if (randomize) { markings.sort(() => Math.random() - 0.5); }
                let finalPlan = []; let currentStockLimits = { ...stockLimits };
                
                while (markings.some(m => inventory[m].qty > 0)) {
                    let bestPattern = null; let bestScore = -Infinity;
                    for (let stockLen of availableStocks) {
                        if (currentStockLimits[stockLen] !== undefined && currentStockLimits[stockLen] <= 0) continue;
                        let currentPattern = { parts: [], remainder: stockLen, tempCounts: {}, stockLength: stockLen, totalPartCount: 0, shortPartCount: 0, itemsUnder1000Count: 0 };
                        // Filter candidates by remaining length
                        let candidateMarkings = markings.filter(m => inventory[m].qty > 0 && inventory[m].length <= currentPattern.remainder - 150);
                        if (candidateMarkings.length === 0) continue;
                        
                        if (mode === 'min_rows' && strategy === 'balanced') {
                            let loop = true;
                            while (loop && currentPattern.remainder >= 150) {
                                loop = false;
                                for (let mKey of candidateMarkings) {
                                    const item = inventory[mKey];
                                    let taken = currentPattern.tempCounts[mKey] || 0;
                                    if (item.qty > taken && item.length <= currentPattern.remainder) {
                                        currentPattern.parts.push({ ...item, count: 1 }); // Use item spread to keep ID/Marking correct
                                        currentPattern.remainder -= item.length;
                                        currentPattern.tempCounts[mKey] = taken + 1;
                                        currentPattern.totalPartCount++;
                                        if (item.length <= 500) currentPattern.shortPartCount++;
                                        loop = true;
                                    }
                                }
                            }
                            // Consolidation for display
                            const consolidatedParts = [];
                            currentPattern.parts.forEach(p => {
                                // Consolidate based on ID (which implies unique row)
                                const existing = consolidatedParts.find(cp => cp.id === p.id);
                                if (existing) existing.count++;
                                else consolidatedParts.push({ ...p, count: 1 });
                            });
                            currentPattern.parts = consolidatedParts;
                        } else {
                            for (let mKey of candidateMarkings) {
                                const item = inventory[mKey]; if (item.qty <= 0) continue;
                                let maxPossibleInOneBar = Math.floor((currentPattern.remainder - 150) / item.length);
                                if (maxPossibleInOneBar <= 0) continue;
                                let countToTake = 1;
                                if (item.qty <= maxPossibleInOneBar) countToTake = item.qty;
                                else { for (let d = maxPossibleInOneBar; d >= 2; d--) { if (item.qty % d === 0) { countToTake = d; break; } } }
                                if (countToTake > 0) {
                                    currentPattern.parts.push({ ...item, count: countToTake });
                                    currentPattern.remainder -= (item.length * countToTake);
                                    currentPattern.tempCounts[mKey] = countToTake;
                                    currentPattern.totalPartCount += countToTake;
                                    if (item.length <= 500) currentPattern.shortPartCount += countToTake;
                                    if (item.length <= 1000) currentPattern.itemsUnder1000Count += countToTake;
                                }
                            }
                        }
                        
                        if (currentPattern.remainder < 150) continue;
                        
                        let score = 0;
                        if (mode === 'min_rows') {
                            if (currentPattern.remainder >= 150 && currentPattern.remainder <= 650) { score += 20000000; }
                            else if (currentPattern.remainder > 650) { score -= (currentPattern.remainder * 50); score -= 5000000; }
                            else score -= 999999999;
                            let maxRepeats = Infinity;
                            currentPattern.parts.forEach(p => {
                                // p.id corresponds to mKey
                                let available = inventory[p.id].qty;
                                maxRepeats = Math.min(maxRepeats, Math.floor(available / p.count));
                            });
                            if (currentStockLimits[stockLen] !== undefined) maxRepeats = Math.min(maxRepeats, currentStockLimits[stockLen]);
                            score += (maxRepeats * 1000000);
                            let itemsCleared = 0;
                            currentPattern.parts.forEach(p => {
                                if (inventory[p.id].qty === p.count * maxRepeats) itemsCleared++;
                            });
                            score += (itemsCleared * 500000);
                            if (currentPattern.shortPartCount > 1) score -= 5000000;
                            if (currentPattern.totalPartCount > 8) score -= 1000000;
                            score -= (stockLen * 10);
                        } else score -= currentPattern.remainder;
                        if (score > bestScore) { bestScore = score; bestPattern = currentPattern; }
                    }
                    
                    if (bestPattern) {
                        let repeatQty = Infinity; 
                        bestPattern.parts.forEach(p => { 
                            repeatQty = Math.min(repeatQty, Math.floor(inventory[p.id].qty / p.count)); 
                        });
                        
                        if (currentStockLimits[bestPattern.stockLength] !== undefined) repeatQty = Math.min(repeatQty, currentStockLimits[bestPattern.stockLength]);
                        
                        if (repeatQty > 0) {
                            if (currentStockLimits[bestPattern.stockLength] !== undefined) currentStockLimits[bestPattern.stockLength] -= repeatQty;
                            const finalParts = [];
                            bestPattern.parts.forEach(p => { 
                                inventory[p.id].qty -= (p.count * repeatQty); 
                                finalParts.push({ ...p, totalQty: p.count * repeatQty }); 
                            });
                            finalPlan.push({ stockLength: bestPattern.stockLength, parts: finalParts, remainder: bestPattern.remainder, qty: repeatQty });
                        } else break;
                    } else {
                        // Fallback: take remaining items one by one
                        markings.forEach(m => {
                            if (inventory[m].qty > 0) {
                                let item = inventory[m]; 
                                let selectedStock = availableStocks.find(s => s >= item.length + 150); 
                                if (!selectedStock) selectedStock = Math.max(...availableStocks);
                                finalPlan.push({ stockLength: selectedStock, parts: [{ ...item, count: 1, totalQty: item.qty }], remainder: selectedStock - item.length, qty: item.qty });
                                item.qty = 0;
                            }
                        });
                    }
                }
                return finalPlan;
            };

            const calculatePlanScore = (plan, mode) => {
                if (mode === 'min_loss') return -(plan.reduce((acc, p) => acc + (p.remainder * p.qty), 0));
                let score = 0; score -= (plan.length * 10000000);
                let markingInSequences = {};
                plan.forEach((pattern, idx) => { pattern.parts.forEach(p => { if (!markingInSequences[p.marking]) markingInSequences[p.marking] = new Set(); markingInSequences[p.marking].add(idx); }); });
                Object.keys(markingInSequences).forEach(m => { if (markingInSequences[m].size > 1) score -= (markingInSequences[m].size * 2000000); });
                plan.forEach(pattern => {
                    if (pattern.remainder < 150) score -= 1000000000;
                    if (pattern.remainder >= 150 && pattern.remainder <= 650) score += 500000; else if (pattern.remainder > 650) score -= (pattern.remainder * 10);
                    let shortCount = pattern.parts.reduce((sum, p) => p.length <= 500 ? sum + p.count : sum, 0); if (shortCount > 1) score -= 1000000;
                    let itemsUnder1000Cuts = pattern.parts.reduce((sum, p) => p.length <= 1000 ? sum + p.count : sum, 0); if (itemsUnder1000Cuts > 1) score += (itemsUnder1000Cuts * 2000);
                });
                return score;
            };

            const runAdvancedOptimization = (items, mode) => {
                const groups = {}; items.forEach(item => { if (!groups[item.specKey]) groups[item.specKey] = []; groups[item.specKey].push(item); }); const computedResults = {};
                Object.keys(groups).forEach(specKey => {
                    let stockW = '100', stockH = '100', stockT = '2.1'; try { const dims = specKey.split(' ')[0] || "100*100"; const thick = specKey.split(' ')[1] || "2.1T"; if (dims.includes('*')) [stockW, stockH] = dims.split('*'); else if (dims.includes('x')) [stockW, stockH] = dims.split('x'); stockT = thick.replace('T', ''); } catch (e) { }
                    const groupItems = groups[specKey];
                    let availableStocks = []; let stockLimits = {};
                    if (isUserStockMode) { userStockList.forEach(s => { if (parseInt(s.w) == parseInt(stockW) && parseInt(s.h) == parseInt(stockH) && s.t == stockT) { if (!stockLimits[s.length]) stockLimits[s.length] = 0; stockLimits[s.length] += s.qty; availableStocks.push(s.length); } }); availableStocks = [...new Set(availableStocks)].sort((a, b) => a - b); }
                    else {
                        let stds = getStockLengths(stockW, stockH, stockT) || [];
                        if (activeTab === 'custom') { customStocks.forEach(s => { if (parseInt(s.w) == parseInt(stockW) && parseInt(s.h) == parseInt(stockH) && s.t == stockT) { if (!stockLimits[s.length]) stockLimits[s.length] = 0; stockLimits[s.length] += s.qty; availableStocks.push(s.length); } }); }
                        stds.forEach(l => { if (!availableStocks.includes(l)) availableStocks.push(l); }); availableStocks.sort((a, b) => a - b);
                    }
                    if (availableStocks.length === 0) availableStocks = [6000];
                    const SIMULATION_RUNS = mode === 'min_rows' ? 2000 : 500; const validPlans = [];
                    // Run with default greedy
                    for (let i = 0; i < SIMULATION_RUNS; i++) {
                        const plan = solvePatternBased(groupItems, availableStocks, mode, 'mixed', true, stockLimits);
                        if (plan.length > 0) { const score = calculatePlanScore(plan, mode); validPlans.push({ plan, score }); }
                    }
                    // Run with balanced strategy for min_rows
                    if (mode === 'min_rows') {
                        for (let i = 0; i < SIMULATION_RUNS; i++) {
                            const plan = solvePatternBased(groupItems, availableStocks, mode, 'balanced', true, stockLimits);
                            if (plan.length > 0) { const score = calculatePlanScore(plan, mode); validPlans.push({ plan, score }); }
                        }
                    }

                    if (validPlans.length > 0) {
                        validPlans.sort((a, b) => {
                            if (b.score !== a.score) return b.score - a.score;
                            return a.plan.reduce((acc, p) => acc + (p.remainder * p.qty), 0) - b.plan.reduce((acc, p) => acc + (p.remainder * p.qty), 0);
                        });
                        const bestPlan = validPlans[0].plan;
                        const totalBars = bestPlan.reduce((acc, p) => acc + p.qty, 0); const totalStockLen = bestPlan.reduce((acc, p) => acc + (p.stockLength * p.qty), 0); const totalLoss = bestPlan.reduce((acc, p) => acc + (p.remainder * p.qty), 0); const lossRate = totalStockLen ? ((totalLoss / totalStockLen) * 100).toFixed(2) : 0;
                        computedResults[specKey] = { plan: bestPlan, summary: { totalBars, lossRate, totalLoss } };
                    }
                });
                return computedResults;
            };

            const processGridData = () => { const data = getCurrentData(); const items = parseItemsFromGrid(data.gridData, data.colMapping, data.spec, data.thickness); if (items.length === 0) { alert("ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); return; } updateCurrentData({ parsedItems: items }); setIsCalculating(true); setTimeout(() => { const resMinRows = runAdvancedOptimization(items, 'min_rows'); const resMinLoss = runAdvancedOptimization(items, 'min_loss'); setResultsByDong(prev => ({ ...prev, [currentDong]: { min_rows: resMinRows, min_loss: resMinLoss } })); setViewMode('result'); setIsCalculating(false); }, 100); };
            const runAllDongs = () => { setIsCalculating(true); setTimeout(() => { const newResults = {}; let processedCount = 0; dongs.forEach(dName => { const dData = dongData[dName]; if (!dData || !dData.gridData || dData.gridData.length === 0) return; const items = parseItemsFromGrid(dData.gridData, dData.colMapping, dData.spec, dData.thickness); if (items.length > 0) { newResults[dName] = { min_rows: runAdvancedOptimization(items, 'min_rows'), min_loss: runAdvancedOptimization(items, 'min_loss') }; processedCount++; } }); if (processedCount > 0) { setResultsByDong(newResults); alert(`ì´ ${processedCount}ê°œ ë™ì˜ ê³„ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`); setViewMode('result'); } else { alert("ê³„ì‚°í•  ë°ì´í„°ê°€ ìˆëŠ” ë™ì´ ì—†ìŠµë‹ˆë‹¤."); } setIsCalculating(false); }, 100); };
            const handleManualToResult = (rows) => { if (!rows || rows.length === 0) { alert("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."); return; } const groups = {}; rows.forEach(row => { const dims = [parseInt(row.w), parseInt(row.h)].sort((a, b) => b - a); const specKey = `${dims[0]}*${dims[1]} ${row.t}T`; if (!groups[specKey]) groups[specKey] = []; const parts = []; if (row.cuts) { row.cuts.forEach(c => { if (c.l && c.count) { parts.push({ length: parseFloat(c.l), count: parseInt(c.count), marking: c.marking || '', totalQty: parseInt(c.count) * parseInt(row.qty) }); } }); } const usedLenInOneBar = parts.reduce((sum, p) => sum + (p.length * p.count), 0); const remainder = parseFloat(row.l) - usedLenInOneBar; groups[specKey].push({ stockLength: parseFloat(row.l), qty: parseInt(row.qty), parts: parts, remainder: remainder }); }); const computedResults = {}; Object.keys(groups).forEach(specKey => { const plan = groups[specKey]; let totalBars = 0; let totalLoss = 0; let totalStockLen = 0; plan.forEach(p => { totalBars += Number(p.qty); totalLoss += (Number(p.remainder) * Number(p.qty)); totalStockLen += (Number(p.stockLength) * Number(p.qty)); }); const lossRate = totalStockLen ? ((totalLoss / totalStockLen) * 100).toFixed(2) : 0; computedResults[specKey] = { plan: plan, summary: { totalBars, totalLoss, lossRate } }; }); setResultsByDong(prev => ({ ...prev, [currentDong]: { ...prev[currentDong], 'manual_result': computedResults } })); setViewMode('result'); };

            // ... (fillWorksheet and handleExcelExport logic UNTOUCHED) ...
            const fillWorksheet = async (worksheet, targetDong, mode) => { const allResults = resultsByDong[targetDong]; const results = allResults[mode]; const specKeys = Object.keys(results).sort(); worksheet.columns = [{ width: 7 }, { width: 7 }, { width: 7 }, { width: 7 }, { width: 12 }, { width: 8 }, { width: 12 }, { width: 8 }, { width: 8 }, { width: 22 }, { width: 12 }, { width: 14 }, { width: 12 }, { width: 5 }, { width: 5 }, { width: 5 }, { width: 20 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 }]; const fontNormal = { name: "Malgun Gothic", size: 11, color: { argb: "FF000000" } }; const fontBold = { name: "Malgun Gothic", size: 11, bold: true, color: { argb: "FF000000" } }; const fontTitle = { name: "Malgun Gothic", size: 15, bold: true, color: { argb: "FF000000" } }; const fontRedBold = { name: "Malgun Gothic", size: 11, bold: true, color: { argb: "FFFF0000" } }; const fillHeader = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCEEFF' } }; const fillTotal = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCEEFF' } }; const fillRed = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFCCBC' } }; const fillYellow = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } }; const fillLightGray = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFEEEEEE' } }; const fillWhite = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFFFF' } }; const borderAll = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } }; const alignCenter = { vertical: 'middle', horizontal: 'center' }; const palette = ["FFFFFFFF", "FFFFF2CC", "FFFCE4EC", "FFE2F0D9", "FFE1F5FE", "FFF3E5F5"]; const specColorMap = {}; specKeys.forEach((key, idx) => { specColorMap[key] = (specKeys.length > 1) ? palette[idx % palette.length] : "FFFFFFFF"; }); let currentRow = 1; const titleRow = worksheet.getRow(currentRow); let titleText = `â€» ${projectInfo.company || 'ì—…ì²´ëª…'}(${projectInfo.site || 'í˜„ì¥ëª…'})`; if (!isNoDongMode) titleText += ` - ${targetDong}`; titleRow.getCell(1).value = titleText; titleRow.getCell(1).font = fontTitle; worksheet.mergeCells(`A${currentRow}:M${currentRow}`); currentRow += 2; const noteParts = []; if (projectInfo.isIronBanding) noteParts.push("ì² ë°´ë”© ë™í‘œê¸°"); if (projectInfo.isUnder1Ton) noteParts.push("1í†¤ ë¯¸ë§Œ ë°´ë”©"); if (projectInfo.note) noteParts.push(projectInfo.note); if (noteParts.length > 0) { const noteRow = worksheet.getRow(currentRow); noteRow.getCell(1).value = noteParts.join(', '); noteRow.getCell(1).font = projectInfo.isIronBanding ? fontBold : fontNormal; noteRow.getCell(1).alignment = alignCenter; if (projectInfo.isIronBanding) noteRow.getCell(1).fill = fillYellow; noteRow.getCell(1).border = borderAll; worksheet.mergeCells(`A${currentRow}:M${currentRow}`); } currentRow += 2; const headers = ['ìˆœë²ˆ', 'ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´(ì›ë³¸)', 'ìˆ˜ëŸ‰', 'ê¸¸ì´(ì»·íŒ…)', 'ì»·íŒ…ìˆ˜', 'ìˆ˜ëŸ‰', 'ë§ˆí‚¹', 'ë³¸ë‹¹ LOSS', 'ì´ LOSS', 'ë¹„ê³ ']; const headerRow = worksheet.getRow(currentRow); headers.forEach((h, i) => { const cell = headerRow.getCell(i + 1); cell.value = h; cell.style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; cell.border = { ...borderAll, bottom: { style: 'medium' } }; }); currentRow++; let seq = 1; const stockSummary = {}; const cutPartMap = new Map(); const statsMap = {}; let grandTotalStockQty = 0; let grandTotalCutQty = 0; let grandTotalLoss = 0; specKeys.forEach(specKey => { const { plan } = results[specKey]; let w = "?", h = "?", t = "?"; try { const dims = specKey.split(' ')[0] || ""; const thick = specKey.split(' ')[1] || ""; if (dims.includes('*')) [w, h] = dims.split('*'); else if (dims.includes('x')) [w, h] = dims.split('x'); t = thick.replace('T', ''); } catch (e) { } const unitWeight = getUnitWeight(w, h, t); const statKey = `${t}|${w}|${h}`; if (!statsMap[statKey]) { statsMap[statKey] = { t, w, h, inputLen: 0, inputWt: 0, prodLen: 0, prodWt: 0 }; } let sortedPlan = [...plan]; sortedPlan.sort((a, b) => b.stockLength - a.stockLength); sortedPlan.forEach(group => { grandTotalStockQty += Number(group.qty || 0); grandTotalLoss += (Number(group.remainder || 0) * Number(group.qty || 0)); const summaryKey = `${t}|${w}|${h}|${group.stockLength}`; if (!stockSummary[summaryKey]) stockSummary[summaryKey] = 0; stockSummary[summaryKey] += Number(group.qty || 0); const inL = Number(group.stockLength || 0) * Number(group.qty || 0); statsMap[statKey].inputLen += inL; statsMap[statKey].inputWt += (inL / 1000 * unitWeight); const groupStartRow = currentRow; const rowHeight = Math.max(1, (group.parts || []).length); const groupColor = { type: 'pattern', pattern: 'solid', fgColor: { argb: specColorMap[specKey] } }; (group.parts || []).forEach((part, pIdx) => { grandTotalCutQty += Number(part.totalQty || 0); const outL = Number(part.length || 0) * Number(part.totalQty || 0); statsMap[statKey].prodLen += outL; statsMap[statKey].prodWt += (outL / 1000 * unitWeight); const partKey = `${t}|${w}|${h}|${part.length}|${part.marking}`; if (cutPartMap.has(partKey)) { cutPartMap.get(partKey).qty += Number(part.totalQty || 0); } else { cutPartMap.set(partKey, { t, w, h, length: part.length, qty: Number(part.totalQty || 0), marking: part.marking, specKey }); } const row = worksheet.getRow(currentRow); if (pIdx === 0) { row.getCell(1).value = seq++; row.getCell(2).value = t; row.getCell(3).value = w; row.getCell(4).value = h; row.getCell(5).value = Number(group.stockLength); row.getCell(6).value = Math.floor(group.qty); } row.getCell(7).value = Number(part.length); row.getCell(8).value = (part.totalQty / group.qty); row.getCell(9).value = Math.floor(part.totalQty); row.getCell(10).value = part.marking; if (pIdx === 0) { row.getCell(11).value = Number(group.remainder); row.getCell(12).value = Number(group.remainder) * Number(group.qty); } for (let c = 1; c <= 13; c++) { const cell = row.getCell(c); cell.border = borderAll; cell.alignment = alignCenter; cell.font = fontNormal; if (c <= 5) { cell.fill = groupColor; } else if (c === 6 || c === 9) { cell.fill = fillLightGray; } else { cell.fill = fillWhite; } if ([5, 6, 9, 11, 12].includes(c)) cell.numFmt = '#,##0'; } row.getCell(5).font = fontBold; row.getCell(7).font = fontBold; row.getCell(9).font = fontBold; if (pIdx === 0 && Number(group.remainder) >= 650) { const lossCell = row.getCell(11); lossCell.fill = fillRed; lossCell.font = fontRedBold; } currentRow++; }); if (rowHeight > 1) { const endRow = groupStartRow + rowHeight - 1; [1, 2, 3, 4, 5, 6, 11, 12, 13].forEach(c => worksheet.mergeCells(groupStartRow, c, endRow, c)); } const lastRowOfGroup = worksheet.getRow(currentRow - 1); for (let c = 1; c <= 13; c++) lastRowOfGroup.getCell(c).border = { ...borderAll, bottom: { style: 'medium' } }; }); }); const totalRow = worksheet.getRow(currentRow); totalRow.getCell(1).value = 'í•© ê³„'; worksheet.mergeCells(currentRow, 1, currentRow, 5); totalRow.getCell(6).value = Math.floor(grandTotalStockQty); totalRow.getCell(7).value = 'í•© ê³„'; worksheet.mergeCells(currentRow, 7, currentRow, 8); totalRow.getCell(9).value = Math.floor(grandTotalCutQty); totalRow.getCell(12).value = grandTotalLoss; for (let c = 1; c <= 13; c++) { const cell = totalRow.getCell(c); cell.fill = fillTotal; cell.font = fontBold; cell.border = borderAll; cell.alignment = alignCenter; if ([6, 9, 12].includes(c)) cell.numFmt = '#,##0'; } const mainTableEndRow = currentRow; currentRow += 4; const statsStartRow = 5; const statsColStart = 17; const statsTitleRow = worksheet.getRow(statsStartRow); statsTitleRow.getCell(statsColStart).value = 'ì¤‘ëŸ‰ ë° ê¸¸ì´ ì§‘ê³„í‘œ'; worksheet.mergeCells(statsStartRow, statsColStart, statsStartRow, statsColStart + 5); statsTitleRow.getCell(statsColStart).style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; const statsHeaderRow = worksheet.getRow(statsStartRow + 1); ['ê·œê²©', 'íˆ¬ì… ê¸¸ì´(m)', 'ìƒì‚° ê¸¸ì´(m)', 'íˆ¬ì… ì¤‘ëŸ‰(kg)', 'ìƒì‚° ì¤‘ëŸ‰(kg)', 'LOSS ì¤‘ëŸ‰(kg)'].forEach((h, i) => { const cell = statsHeaderRow.getCell(statsColStart + i); cell.value = h; cell.style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; }); let grandInLen = 0, grandProdLen = 0, grandInWt = 0, grandProdWt = 0; let statsRowIdx = statsStartRow + 2; const sortedStatKeys = Object.keys(statsMap).sort((a, b) => { const [t1, w1, h1] = a.split('|').map(Number); const [t2, w2, h2] = b.split('|').map(Number); if (w1 !== w2) return w2 - w1; if (h1 !== h2) return h2 - h1; return t1 - t2; }); sortedStatKeys.forEach(k => { const d = statsMap[k]; grandInLen += (d.inputLen || 0); grandProdLen += (d.prodLen || 0); grandInWt += (d.inputWt || 0); grandProdWt += (d.prodWt || 0); const lossWt = (d.inputWt || 0) - (d.prodWt || 0); const r = worksheet.getRow(statsRowIdx); r.getCell(statsColStart).value = `${d.w}*${d.h}*${d.t}T`; r.getCell(statsColStart + 1).value = (d.inputLen / 1000); r.getCell(statsColStart + 2).value = (d.prodLen / 1000); r.getCell(statsColStart + 3).value = d.inputWt; r.getCell(statsColStart + 4).value = d.prodWt; r.getCell(statsColStart + 5).value = lossWt; for (let c = 0; c < 6; c++) { const cell = r.getCell(statsColStart + c); cell.border = borderAll; cell.alignment = alignCenter; cell.font = fontNormal; if (c > 0) cell.numFmt = '#,##0.000'; } statsRowIdx++; }); const statsTotalRow = worksheet.getRow(statsRowIdx); statsTotalRow.getCell(statsColStart).value = 'ì „ì²´ í•©ê³„'; statsTotalRow.getCell(statsColStart + 1).value = (grandInLen / 1000); statsTotalRow.getCell(statsColStart + 2).value = (grandProdLen / 1000); statsTotalRow.getCell(statsColStart + 3).value = grandInWt; statsTotalRow.getCell(statsColStart + 4).value = grandProdWt; statsTotalRow.getCell(statsColStart + 5).value = (grandInWt - grandProdWt); for (let c = 0; c < 6; c++) { const cell = statsTotalRow.getCell(statsColStart + c); cell.style = { font: fontBold, fill: fillTotal, border: borderAll, alignment: alignCenter }; if (c > 0) cell.numFmt = '#,##0.000'; } const rawStartRow = currentRow; let rawRowIdx = rawStartRow + 2; let rawTotalQtyCalc = 0; worksheet.mergeCells(rawStartRow, 1, rawStartRow, 5); worksheet.getRow(rawStartRow).getCell(1).value = 'ì›ë³¸'; worksheet.getRow(rawStartRow).getCell(1).style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; const rawHeaderRow = worksheet.getRow(rawStartRow + 1); ['ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´', 'ìˆ˜ëŸ‰'].forEach((h, i) => { const cell = rawHeaderRow.getCell(i + 1); cell.value = h; cell.style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; }); const sortedStockKeys = Object.keys(stockSummary).sort((a, b) => { const [t1, w1, h1, l1] = a.split('|').map(Number); const [t2, w2, h2, l2] = b.split('|').map(Number); if (w1 !== w2) return w2 - w1; if (h1 !== h2) return h2 - h1; if (t1 !== t2) return t2 - t1; return l2 - l1; }); sortedStockKeys.forEach(key => { const [t, w, h, l] = key.split('|'); const qty = stockSummary[key]; rawTotalQtyCalc += qty; const r = worksheet.getRow(rawRowIdx); r.getCell(1).value = t; r.getCell(2).value = w; r.getCell(3).value = h; r.getCell(4).value = Number(l); r.getCell(5).value = qty; const rowSpecKey = `${[parseInt(w), parseInt(h)].sort((a, b) => b - a).join('*')} ${t}T`; const cellFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: specColorMap[rowSpecKey] || "FFFFFFFF" } }; for (let c = 1; c <= 5; c++) { const cell = r.getCell(c); cell.border = borderAll; cell.alignment = alignCenter; cell.font = fontNormal; cell.fill = cellFill; } rawRowIdx++; }); const rawTotalRow = worksheet.getRow(rawRowIdx); rawTotalRow.getCell(1).value = 'í•©ê³„'; worksheet.mergeCells(rawRowIdx, 1, rawRowIdx, 4); rawTotalRow.getCell(5).value = rawTotalQtyCalc; [1, 2, 3, 4, 5].forEach(c => { const cell = rawTotalRow.getCell(c); cell.style = { font: fontBold, fill: fillTotal, border: borderAll, alignment: alignCenter }; }); const prodStartRow = rawStartRow; let prodRowIdx = prodStartRow + 2; let prodTotalQtyCalc = 0; worksheet.mergeCells(prodStartRow, 7, prodStartRow, 12); worksheet.getRow(prodStartRow).getCell(7).value = 'ìƒì‚°ì œí’ˆ'; worksheet.getRow(prodStartRow).getCell(7).style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; const prodHeaderRow = worksheet.getRow(prodStartRow + 1); ['ë‘ê»˜', 'ì¥ë³€', 'ë‹¨ë³€', 'ê¸¸ì´', 'ìˆ˜ëŸ‰', 'ë§ˆí‚¹'].forEach((h, i) => { const cell = prodHeaderRow.getCell(7 + i); cell.value = h; cell.style = { font: fontBold, fill: fillHeader, alignment: alignCenter, border: borderAll }; }); const sortedParts = Array.from(cutPartMap.values()).sort((a, b) => { if (a.w !== b.w) return b.w - a.w; if (a.h !== b.h) return b.h - a.h; if (a.t !== b.t) return b.t - a.t; if (b.length !== a.length) return b.length - a.length; return String(a.marking).localeCompare(String(b.marking)); }); sortedParts.forEach(p => { prodTotalQtyCalc += p.qty; const r = worksheet.getRow(prodRowIdx); r.getCell(7).value = p.t; r.getCell(8).value = p.w; r.getCell(9).value = p.h; r.getCell(10).value = p.length; r.getCell(11).value = p.qty; r.getCell(12).value = p.marking; const cellFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: specColorMap[p.specKey] || "FFFFFFFF" } }; for (let c = 7; c <= 12; c++) { const cell = r.getCell(c); cell.border = borderAll; cell.alignment = alignCenter; cell.font = fontNormal; cell.fill = cellFill; } prodRowIdx++; }); const prodTotalRow = worksheet.getRow(prodRowIdx); prodTotalRow.getCell(7).value = 'í•©ê³„'; worksheet.mergeCells(prodRowIdx, 7, prodRowIdx, 10); prodTotalRow.getCell(11).value = prodTotalQtyCalc; [7, 8, 9, 10, 11, 12].forEach(c => { const cell = prodTotalRow.getCell(c); cell.style = { font: fontBold, fill: fillTotal, border: borderAll, alignment: alignCenter }; }); const maxPrintRow = Math.max(mainTableEndRow, rawRowIdx, prodRowIdx); worksheet.pageSetup = { orientation: 'portrait', paperSize: 9, fitToPage: true, fitToWidth: 1, fitToHeight: 0, margins: { left: 0.25, right: 0.25, top: 0.5, bottom: 0.5, header: 0.3, footer: 0.3 }, printArea: `A1:M${maxPrintRow}` }; };
            const handleExcelExport = async (targetType, modeType) => { try { const targets = targetType === 'current' ? [currentDong] : dongs; let hasSheets = false; const masterWorkbook = new ExcelJS.Workbook(); for (const dName of targets) { const res = resultsByDong[dName]; if (res) { if (modeType === 'both') { if (res['min_rows']) { const sheet = masterWorkbook.addWorksheet(`${dName}_ì‘ì—…`); await fillWorksheet(sheet, dName, 'min_rows'); hasSheets = true; } if (res['min_loss']) { const sheet = masterWorkbook.addWorksheet(`${dName}_LOSS`); await fillWorksheet(sheet, dName, 'min_loss'); hasSheets = true; } } else { if (res[modeType]) { const sheetName = `${dName}_${modeType === 'min_rows' ? 'ì‘ì—…' : (modeType === 'min_loss' ? 'LOSS' : 'ìˆ˜ë™')}`; const sheet = masterWorkbook.addWorksheet(sheetName); await fillWorksheet(sheet, dName, modeType); hasSheets = true; } } } } if (hasSheets) { const buffer = await masterWorkbook.xlsx.writeBuffer(); let fileName = `${projectInfo.company || 'ì—…ì²´ëª…'}(${projectInfo.site || 'í˜„ì¥ëª…'})`; if (!isNoDongMode) fileName += `-${currentDong}`; fileName += '.xlsx'; const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }); saveAs(blob, fileName); setIsExcelModalOpen(false); alert("ë‹¤ìš´ë¡œë“œê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\n[ExcelJS] ì¸ì‡„ ì„¤ì •ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤."); } else { alert("ì €ì¥í•  ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ì„ íƒí•˜ì‹  ëª¨ë“œì— ëŒ€í•œ ê³„ì‚° ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."); } } catch (error) { console.error(error); alert("ì—‘ì…€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + error.message); } };

            return (
                <div className="min-h-screen bg-gray-50 text-gray-900 font-sans flex">
                    <Sidebar viewMode={viewMode} setViewMode={setViewMode} projectInfo={projectInfo} setProjectInfo={setProjectInfo} isNoDongMode={isNoDongMode} setIsNoDongMode={setIsNoDongMode} />
                    <div className="flex-1 ml-64 p-8 print:m-0 print:p-0">
                        {viewMode === 'input' && (<InputView currentDong={currentDong} dongs={dongs} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} data={getCurrentData()} updateCurrentData={updateCurrentData} activeTab={activeTab} setActiveTab={setActiveTab} customStocks={customStocks} setCustomStocks={setCustomStocks} processGridData={processGridData} handlePaste={handlePaste} runAllDongs={runAllDongs} globalSettings={STANDARD_STOCKS} isUserStockMode={isUserStockMode} setIsUserStockMode={setIsUserStockMode} userStockList={userStockList} setUserStockList={setUserStockList} setViewMode={setViewMode} isCalculating={isCalculating} isNoDongMode={isNoDongMode} handleFetchStock={handleFetchStock} isGapiReady={isGapiReady} isLoggedIn={isLoggedIn} handleLogin={handleLogin} />)}
                        {viewMode === 'result' && (<ResultView currentDong={currentDong} dongs={dongs} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} resultsByDong={resultsByDong} runAllDongs={runAllDongs} openExcelModal={() => setIsExcelModalOpen(true)} openStockModal={() => setIsStockModalOpen(true)} setViewMode={setViewMode} setManualData={setManualData} projectInfo={projectInfo} isNoDongMode={isNoDongMode} />)}
                        {viewMode === 'manual' && (<ManualCPView dongs={dongs} currentDong={currentDong} setCurrentDong={setCurrentDong} addDong={addDong} deleteDong={deleteDong} renameDong={renameDong} projectInfo={projectInfo} manualData={manualData} setManualData={setManualData} onConvert={handleManualToResult} parsedItems={getCurrentData().parsedItems.length > 0 ? getCurrentData().parsedItems : parseItemsFromGrid(getCurrentData().gridData, getCurrentData().colMapping, getCurrentData().spec, getCurrentData().thickness)} isNoDongMode={isNoDongMode} />)}
                    </div>
                    <ExcelExportModal isOpen={isExcelModalOpen} onClose={() => setIsExcelModalOpen(false)} onConfirm={handleExcelExport} dongs={dongs} />
                    <StockDeductModal isOpen={isStockModalOpen} onClose={() => setIsStockModalOpen(false)} onConfirm={handleUpdateStock} dongs={dongs} isLoggedIn={isLoggedIn} handleLogin={handleLogin} />
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>

</html>